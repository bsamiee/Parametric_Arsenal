using System.Collections.Frozen;
using System.Diagnostics.Contracts;
using System.Runtime.CompilerServices;
using Arsenal.Core.Context;
using Arsenal.Core.Results;
using Arsenal.Core.Validation;
using Rhino;
using Rhino.Geometry;
using Rhino.Geometry.Intersect;
using RhinoIntersect = Rhino.Geometry.Intersect.Intersection;

namespace Arsenal.Rhino.Intersection;

/// <summary>Unified intersection result containing points, curves, and parametric information.</summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Naming", "MA0048:File name must match type name", Justification = "Internal result type colocated with strategies")]
internal sealed record IntersectionResult(
    IReadOnlyList<Point3d> Points,
    IntersectionMethod Method,
    IReadOnlyList<Curve>? Curves = null,
    IReadOnlyList<double>? ParametersA = null,
    IReadOnlyList<double>? ParametersB = null,
    IReadOnlyList<int>? FaceIndices = null,
    IReadOnlyList<Polyline>? Sections = null);

/// <summary>Intersection algorithm implementations with RhinoCommon Intersect SDK integration.</summary>
internal static class IntersectionStrategies {
    private static readonly FrozenDictionary<(IntersectionMethod, Type, Type), (ValidationMode Mode, Func<object, object, double, IntersectionMethod, IGeometryContext, Vector3d?, int?, Result<IntersectionResult>> Compute)> _dispatch =
        new Dictionary<(IntersectionMethod, Type, Type), (ValidationMode, Func<object, object, double, IntersectionMethod, IGeometryContext, Vector3d?, int?, Result<IntersectionResult>>)> {
            [(IntersectionMethod.CurveCurve, typeof(Curve), typeof(Curve))] = (ValidationMode.Standard | ValidationMode.Degeneracy, (a, b, tol, m, _, _, _) => RhinoIntersect.CurveCurve((Curve)a, (Curve)b, tol, tol) switch {
                null => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Operation.ComputationFailed),
                CurveIntersections { Count: > 0 } r => ResultFactory.Create(value: new IntersectionResult([.. from e in r select e.PointA], m, Curves: [.. from e in r where e.IsOverlap from c in new[] { ((Curve)a).Trim(e.OverlapA) } where c is not null select c], ParametersA: [.. from e in r select e.ParameterA], ParametersB: [.. from e in r select e.ParameterB])),
                _ => ResultFactory.Create(value: new IntersectionResult([], m)),
            }),
            [(IntersectionMethod.CurveCurveValidate, typeof(Curve), typeof(Curve))] = (ValidationMode.Standard | ValidationMode.Degeneracy, (a, b, tol, m, _, _, _) => RhinoIntersect.CurveCurveValidate((Curve)a, (Curve)b, tol, tol, out int[] indices, out TextLog log) switch {
                null => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Operation.ComputationFailed),
                CurveIntersections { Count: > 0 } r => ResultFactory.Create(value: new IntersectionResult([.. from e in r select e.PointA], m, Curves: [.. from e in r where e.IsOverlap from c in new[] { ((Curve)a).Trim(e.OverlapA) } where c is not null select c], ParametersA: [.. from e in r select e.ParameterA], ParametersB: [.. from e in r select e.ParameterB], FaceIndices: indices.Length > 0 ? [.. indices] : null)),
                _ => ResultFactory.Create(value: new IntersectionResult([], m)),
            }),
            [(IntersectionMethod.CurveSurface, typeof(Curve), typeof(Surface))] = (ValidationMode.Standard, (a, b, tol, m, _, _, _) => RhinoIntersect.CurveSurface((Curve)a, (Surface)b, tol, tol) switch { CurveIntersections { Count: > 0 } r => ResultFactory.Create(value: new IntersectionResult([.. from e in r select e.PointA], m, ParametersA: [.. from e in r select e.ParameterA], ParametersB: [.. from e in r select e.ParameterB])), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.CurveBrep, typeof(Curve), typeof(Brep))] = (ValidationMode.Standard | ValidationMode.Topology, (a, b, tol, m, _, _, _) => RhinoIntersect.CurveBrep((Curve)a, (Brep)b, tol, out Curve[] c, out Point3d[] p) switch { true when p.Length > 0 || c.Length > 0 => ResultFactory.Create(value: new IntersectionResult([.. p], m, Curves: c.Length > 0 ? [.. c] : null)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.CurveBrepFace, typeof(Curve), typeof(BrepFace))] = (ValidationMode.Standard | ValidationMode.Topology, (a, b, tol, m, _, _, _) => RhinoIntersect.CurveBrepFace((Curve)a, (BrepFace)b, tol, out Curve[] c, out Point3d[] p) switch { true when p.Length > 0 || c.Length > 0 => ResultFactory.Create(value: new IntersectionResult([.. p], m, Curves: c.Length > 0 ? [.. c] : null)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.CurvePlane, typeof(Curve), typeof(Plane))] = (ValidationMode.Standard | ValidationMode.Degeneracy, (a, b, tol, m, _, _, _) => RhinoIntersect.CurvePlane((Curve)a, (Plane)b, tol) switch { CurveIntersections { Count: > 0 } r => ResultFactory.Create(value: new IntersectionResult([.. from e in r select e.PointA], m, ParametersA: [.. from e in r select e.ParameterA])), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.CurveLine, typeof(Curve), typeof(Line))] = (ValidationMode.Standard | ValidationMode.Degeneracy, (a, b, tol, m, _, _, _) => RhinoIntersect.CurveLine((Curve)a, (Line)b, tol, tol) switch { CurveIntersections { Count: > 0 } r => ResultFactory.Create(value: new IntersectionResult([.. from e in r select e.PointA], m, ParametersA: [.. from e in r select e.ParameterA], ParametersB: [.. from e in r select e.ParameterB])), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.CurveSelf, typeof(Curve), typeof(Curve))] = (ValidationMode.Standard | ValidationMode.Degeneracy, (a, _, tol, m, _, _, _) => RhinoIntersect.CurveSelf((Curve)a, tol) switch { null => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Operation.ComputationFailed), CurveIntersections { Count: > 0 } r => ResultFactory.Create(value: new IntersectionResult([.. from e in r select e.PointA], m, ParametersA: [.. from e in r select e.ParameterA])), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.BrepBrep, typeof(Brep), typeof(Brep))] = (ValidationMode.Standard | ValidationMode.Topology, (a, b, tol, m, _, _, _) => RhinoIntersect.BrepBrep((Brep)a, (Brep)b, tol, out Curve[] c, out Point3d[] p) switch { true when p.Length > 0 || c.Length > 0 => ResultFactory.Create(value: new IntersectionResult([.. p], m, Curves: c.Length > 0 ? [.. c] : null)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.BrepPlane, typeof(Brep), typeof(Plane))] = (ValidationMode.Standard | ValidationMode.Topology, (a, b, tol, m, _, _, _) => RhinoIntersect.BrepPlane((Brep)a, (Plane)b, tol, out Curve[] c, out Point3d[] pts) switch { true when pts.Length > 0 || c.Length > 0 => ResultFactory.Create(value: new IntersectionResult([.. pts], m, Curves: c.Length > 0 ? [.. c] : null)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.BrepSurface, typeof(Brep), typeof(Surface))] = (ValidationMode.Standard | ValidationMode.Topology, (a, b, tol, m, _, _, _) => RhinoIntersect.BrepSurface((Brep)a, (Surface)b, tol, out Curve[] c, out Point3d[] p) switch { true when p.Length > 0 || c.Length > 0 => ResultFactory.Create(value: new IntersectionResult([.. p], m, Curves: c.Length > 0 ? [.. c] : null)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.SurfaceSurface, typeof(Surface), typeof(Surface))] = (ValidationMode.Standard, (a, b, tol, m, _, _, _) => RhinoIntersect.SurfaceSurface((Surface)a, (Surface)b, tol, out Curve[] c, out Point3d[] pts) switch { true when pts.Length > 0 || c.Length > 0 => ResultFactory.Create(value: new IntersectionResult([.. pts], m, Curves: c.Length > 0 ? [.. c] : null)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.MeshMesh, typeof(Mesh), typeof(Mesh))] = (ValidationMode.MeshSpecific, (a, b, _, m, _, _, _) => RhinoIntersect.MeshMeshFast((Mesh)a, (Mesh)b) switch { null => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Operation.ComputationFailed), Line[] { Length: > 0 } lines => ResultFactory.Create(value: new IntersectionResult([.. from l in lines select l.From, .. from l in lines select l.To], m)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.MeshMeshAccurate, typeof(Mesh), typeof(Mesh))] = (ValidationMode.MeshSpecific, (a, b, tol, m, _, _, _) => RhinoIntersect.MeshMeshAccurate((Mesh)a, (Mesh)b, tol) switch { null => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Operation.ComputationFailed), Point3d[] { Length: > 0 } pts => ResultFactory.Create(value: new IntersectionResult([.. pts], m)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.MeshRay, typeof(Mesh), typeof(Ray3d))] = (ValidationMode.MeshSpecific, (a, b, _, m, _, _, _) => { double d = RhinoIntersect.MeshRay((Mesh)a, (Ray3d)b); return d >= 0 ? ResultFactory.Create(value: new IntersectionResult([((Ray3d)b).PointAt(d)], m, ParametersA: [d])) : ResultFactory.Create(value: new IntersectionResult([], m)); }),
            [(IntersectionMethod.MeshPlane, typeof(Mesh), typeof(Plane))] = (ValidationMode.MeshSpecific, (a, b, _, m, _, _, _) => RhinoIntersect.MeshPlane((Mesh)a, (Plane)b) switch { null => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Operation.ComputationFailed), Polyline[] { Length: > 0 } s => ResultFactory.Create(value: new IntersectionResult([.. from pl in s from pt in pl select pt], m, Sections: [.. s])), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.MeshLine, typeof(Mesh), typeof(Line))] = (ValidationMode.MeshSpecific, (a, b, _, m, _, _, _) => RhinoIntersect.MeshLine((Mesh)a, (Line)b) switch { null => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Operation.ComputationFailed), Point3d[] { Length: > 0 } pts => ResultFactory.Create(value: new IntersectionResult([.. pts], m)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.MeshLineSorted, typeof(Mesh), typeof(Line))] = (ValidationMode.MeshSpecific, (a, b, _, m, _, _, _) => RhinoIntersect.MeshLineSorted((Mesh)a, (Line)b, out int[] faceIds) switch { null => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Operation.ComputationFailed), Point3d[] { Length: > 0 } pts => ResultFactory.Create(value: new IntersectionResult([.. pts], m, FaceIndices: faceIds.Length > 0 ? [.. faceIds] : null)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.MeshPolyline, typeof(Mesh), typeof(PolylineCurve))] = (ValidationMode.MeshSpecific, (a, b, _, m, _, _, _) => RhinoIntersect.MeshPolyline((Mesh)a, (PolylineCurve)b, out int[] faceIds) switch { null => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Operation.ComputationFailed), Point3d[] { Length: > 0 } pts => ResultFactory.Create(value: new IntersectionResult([.. pts], m, FaceIndices: faceIds.Length > 0 ? [.. faceIds] : null)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.MeshPolylineSorted, typeof(Mesh), typeof(PolylineCurve))] = (ValidationMode.MeshSpecific, (a, b, _, m, _, _, _) => RhinoIntersect.MeshPolylineSorted((Mesh)a, (PolylineCurve)b, out int[] faceIds) switch { null => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Operation.ComputationFailed), Point3d[] { Length: > 0 } pts => ResultFactory.Create(value: new IntersectionResult([.. pts], m, FaceIndices: faceIds.Length > 0 ? [.. faceIds] : null)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.LineLine, typeof(Line), typeof(Line))] = (ValidationMode.Standard, (a, b, tol, m, _, _, _) => RhinoIntersect.LineLine((Line)a, (Line)b, out double pa, out double pb, tol, strict: false) ? ResultFactory.Create(value: new IntersectionResult([((Line)a).PointAt(pa)], m, ParametersA: [pa], ParametersB: [pb])) : ResultFactory.Create(value: new IntersectionResult([], m))),
            [(IntersectionMethod.LineBox, typeof(Line), typeof(BoundingBox))] = (ValidationMode.Standard, (a, b, tol, m, _, _, _) => RhinoIntersect.LineBox((Line)a, (BoundingBox)b, tol, out Interval i) ? ResultFactory.Create(value: new IntersectionResult([((Line)a).PointAt(i.Min), ((Line)a).PointAt(i.Max)], m, ParametersA: [i.Min, i.Max])) : ResultFactory.Create(value: new IntersectionResult([], m))),
            [(IntersectionMethod.LinePlane, typeof(Line), typeof(Plane))] = (ValidationMode.Standard, (a, b, _, m, _, _, _) => RhinoIntersect.LinePlane((Line)a, (Plane)b, out double param) ? ResultFactory.Create(value: new IntersectionResult([((Line)a).PointAt(param)], m, ParametersA: [param])) : ResultFactory.Create(value: new IntersectionResult([], m))),
            [(IntersectionMethod.LineSphere, typeof(Line), typeof(Sphere))] = (ValidationMode.Standard, (a, b, _, m, _, _, _) => RhinoIntersect.LineSphere((Line)a, (Sphere)b, out Point3d p1, out Point3d p2) switch { LineSphereIntersection.Multiple => ResultFactory.Create(value: new IntersectionResult([p1, p2], m)), LineSphereIntersection.Single => ResultFactory.Create(value: new IntersectionResult([p1], m)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.LineCylinder, typeof(Line), typeof(Cylinder))] = (ValidationMode.Standard, (a, b, _, m, _, _, _) => RhinoIntersect.LineCylinder((Line)a, (Cylinder)b, out Point3d p1, out Point3d p2) switch { LineCylinderIntersection.Multiple => ResultFactory.Create(value: new IntersectionResult([p1, p2], m)), LineCylinderIntersection.Single => ResultFactory.Create(value: new IntersectionResult([p1], m)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.LineCircle, typeof(Line), typeof(Circle))] = (ValidationMode.Standard, (a, b, _, m, ctx, _, _) => RhinoIntersect.LineCircle((Line)a, (Circle)b, out double t1, out Point3d p1, out double t2, out Point3d p2) switch { true when p1.DistanceTo(p2) > ctx.AbsoluteTolerance => ResultFactory.Create(value: new IntersectionResult([p1, p2], m, ParametersA: [t1, t2])), true => ResultFactory.Create(value: new IntersectionResult([p1], m, ParametersA: [t1])), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.PlanePlane, typeof(Plane), typeof(Plane))] = (ValidationMode.Standard, (a, b, _, m, _, _, _) => RhinoIntersect.PlanePlane((Plane)a, (Plane)b, out Line line) ? ResultFactory.Create(value: new IntersectionResult([], m, Curves: [new LineCurve(line)])) : ResultFactory.Create(value: new IntersectionResult([], m))),
            [(IntersectionMethod.PlanePlanePlane, typeof(ValueTuple<Plane, Plane>), typeof(Plane))] = (ValidationMode.Standard, (a, b, _, m, _, _, _) => { (Plane p1, Plane p2) = ((Plane, Plane))a; return RhinoIntersect.PlanePlanePlane(p1, p2, (Plane)b, out Point3d pt) ? ResultFactory.Create(value: new IntersectionResult([pt], m)) : ResultFactory.Create(value: new IntersectionResult([], m)); }),
            [(IntersectionMethod.PlaneCircle, typeof(Plane), typeof(Circle))] = (ValidationMode.Standard, (a, b, _, m, _, _, _) => RhinoIntersect.PlaneCircle((Plane)a, (Circle)b, out double t1, out double t2) switch { CirclePlaneIntersection.Tangent => ResultFactory.Create(value: new IntersectionResult([((Circle)b).PointAt(t1)], m, ParametersB: [t1])), CirclePlaneIntersection.Secant => ResultFactory.Create(value: new IntersectionResult([((Circle)b).PointAt(t1), ((Circle)b).PointAt(t2)], m, ParametersB: [t1, t2])), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.PlaneSphere, typeof(Plane), typeof(Sphere))] = (ValidationMode.Standard, (a, b, _, m, _, _, _) => RhinoIntersect.PlaneSphere((Plane)a, (Sphere)b, out Circle circle) switch { PlaneSphereIntersection.Circle => ResultFactory.Create(value: new IntersectionResult([], m, Curves: [new ArcCurve(circle)])), PlaneSphereIntersection.Point => ResultFactory.Create(value: new IntersectionResult([circle.Center], m)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.PlaneBoundingBox, typeof(Plane), typeof(BoundingBox))] = (ValidationMode.Standard, (a, b, _, m, _, _, _) => RhinoIntersect.PlaneBoundingBox((Plane)a, (BoundingBox)b, out Polyline poly) switch { true when poly?.Count > 0 => ResultFactory.Create(value: new IntersectionResult([.. from pt in poly select pt], m, Sections: [poly])), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.SphereSphere, typeof(Sphere), typeof(Sphere))] = (ValidationMode.Standard, (a, b, _, m, _, _, _) => RhinoIntersect.SphereSphere((Sphere)a, (Sphere)b, out Circle circle) switch { SphereSphereIntersection.Circle => ResultFactory.Create(value: new IntersectionResult([], m, Curves: [new ArcCurve(circle)])), SphereSphereIntersection.Point => ResultFactory.Create(value: new IntersectionResult([circle.Center], m)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.CircleCircle, typeof(Circle), typeof(Circle))] = (ValidationMode.Standard, (a, b, _, m, ctx, _, _) => RhinoIntersect.CircleCircle((Circle)a, (Circle)b, out Point3d p1, out Point3d p2) switch { CircleCircleIntersection.Single or CircleCircleIntersection.Multiple => ResultFactory.Create(value: new IntersectionResult(p1.DistanceTo(p2) > ctx.AbsoluteTolerance ? [p1, p2] : [p1], m)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.ArcArc, typeof(Arc), typeof(Arc))] = (ValidationMode.Standard, (a, b, _, m, ctx, _, _) => RhinoIntersect.ArcArc((Arc)a, (Arc)b, out Point3d p1, out Point3d p2) switch { true when p1.DistanceTo(p2) > ctx.AbsoluteTolerance => ResultFactory.Create(value: new IntersectionResult([p1, p2], m)), true when p1.IsValid => ResultFactory.Create(value: new IntersectionResult([p1], m)), _ => ResultFactory.Create(value: new IntersectionResult([], m)), }),
            [(IntersectionMethod.ProjectPointsToBreps, typeof(Point3d[]), typeof(Brep[]))] = (ValidationMode.Standard | ValidationMode.Topology, (a, b, _, m, _, dir, _) => (dir?.IsValid, dir?.Length) switch { (true, > RhinoMath.ZeroTolerance) => ResultFactory.Create(value: new IntersectionResult([.. RhinoIntersect.ProjectPointsToBreps((Brep[])b, (Point3d[])a, dir.Value, RhinoMath.ZeroTolerance)], m)), _ => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Parameters.InvalidProjectionDirection), }),
            [(IntersectionMethod.ProjectPointsToBrepsEx, typeof(Point3d[]), typeof(Brep[]))] = (ValidationMode.Standard | ValidationMode.Topology, (a, b, _, m, _, dir, _) => (dir?.IsValid, dir?.Length) switch { (true, > RhinoMath.ZeroTolerance) => ResultFactory.Create(value: new IntersectionResult([.. RhinoIntersect.ProjectPointsToBrepsEx((Brep[])b, (Point3d[])a, dir.Value, RhinoMath.ZeroTolerance, out int[] indices)], m, FaceIndices: indices.Length > 0 ? [.. indices] : null)), _ => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Parameters.InvalidProjectionDirection), }),
            [(IntersectionMethod.ProjectPointsToMeshes, typeof(Point3d[]), typeof(Mesh[]))] = (ValidationMode.MeshSpecific, (a, b, _, m, _, dir, _) => (dir?.IsValid, dir?.Length) switch { (true, > RhinoMath.ZeroTolerance) => ResultFactory.Create(value: new IntersectionResult([.. RhinoIntersect.ProjectPointsToMeshes((Mesh[])b, (Point3d[])a, dir.Value, RhinoMath.ZeroTolerance)], m)), _ => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Parameters.InvalidProjectionDirection), }),
            [(IntersectionMethod.ProjectPointsToMeshesEx, typeof(Point3d[]), typeof(Mesh[]))] = (ValidationMode.MeshSpecific, (a, b, _, m, _, dir, _) => (dir?.IsValid, dir?.Length) switch { (true, > RhinoMath.ZeroTolerance) => ResultFactory.Create(value: new IntersectionResult([.. RhinoIntersect.ProjectPointsToMeshesEx((Mesh[])b, (Point3d[])a, dir.Value, RhinoMath.ZeroTolerance, out int[] indices)], m, FaceIndices: indices.Length > 0 ? [.. indices] : null)), _ => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Parameters.InvalidProjectionDirection), }),
            [(IntersectionMethod.RayShoot, typeof(Ray3d), typeof(GeometryBase[]))] = (ValidationMode.Standard, (a, b, _, m, _, _, maxHits) => (maxHits, ((Ray3d)a).Direction.Length) switch { (> 0, > RhinoMath.ZeroTolerance) => ResultFactory.Create(value: new IntersectionResult([.. RhinoIntersect.RayShoot((Ray3d)a, (IEnumerable<GeometryBase>)(GeometryBase[])b, maxHits.Value)], m)), (null or <= 0, _) => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Parameters.InvalidMaxHitCount), _ => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Parameters.InvalidRayDirection), }),
        }.ToFrozenDictionary();

    [Pure, MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static Result<IntersectionResult> Intersect<T1, T2>(T1 geometryA, T2 geometryB, IntersectionMethod method, IGeometryContext context, double? tolerance = null, Vector3d? projectionDirection = null, int? maxHitCount = null) where T1 : notnull where T2 : notnull =>
        _dispatch.TryGetValue((method, typeof(T1), typeof(T2)), out (ValidationMode mode, Func<object, object, double, IntersectionMethod, IGeometryContext, Vector3d?, int?, Result<IntersectionResult>> compute) entry) switch {
            true => (method, geometryA, geometryB) switch {
                (IntersectionMethod.CurveSelf, Curve c, _) => ResultFactory.Create(value: c).Validate(args: [context, entry.mode]).Bind(_ => entry.compute(c, c, tolerance ?? context.AbsoluteTolerance, method, context, projectionDirection, maxHitCount)),
                (IntersectionMethod.PlanePlanePlane, ValueTuple<Plane, Plane> planes, Plane p3) => entry.compute(planes, p3, tolerance ?? context.AbsoluteTolerance, method, context, projectionDirection, maxHitCount),
                (_, GeometryBase ga, GeometryBase gb) => ResultFactory.Create(value: (ga, gb)).Validate(args: [context, entry.mode]).Bind(_ => entry.compute(geometryA!, geometryB!, tolerance ?? context.AbsoluteTolerance, method, context, projectionDirection, maxHitCount)),
                (_, GeometryBase ga, _) => ResultFactory.Create(value: ga).Validate(args: [context, entry.mode]).Bind(_ => entry.compute(geometryA!, geometryB!, tolerance ?? context.AbsoluteTolerance, method, context, projectionDirection, maxHitCount)),
                _ => entry.compute(geometryA!, geometryB!, tolerance ?? context.AbsoluteTolerance, method, context, projectionDirection, maxHitCount),
            },
            false => ResultFactory.Create<IntersectionResult>(error: IntersectionErrors.Operation.UnsupportedMethod),
        };
}
