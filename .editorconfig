# Top-most EditorConfig file
root = true

# All files
[*]
charset = utf-8
insert_final_newline = true
trim_trailing_whitespace = true

# C# files
[*.cs]
indent_style = space
indent_size = 4

# CORE C# SETTINGS - ERROR
# Basic editor configuration and file-scoped namespace enforcement

# File-scoped namespaces (MANDATORY per standards.md)
csharp_style_namespace_declarations = file_scoped:error
dotnet_diagnostic.IDE0160.severity = error  # Use file-scoped namespace (block to file-scoped)
dotnet_diagnostic.IDE0161.severity = error  # Use file-scoped namespace (file-scoped to block)

# Using directives organization
dotnet_diagnostic.IDE0005.severity = error  # Remove unnecessary using directives
dotnet_diagnostic.IDE0065.severity = warning  # Using directive placement
dotnet_separate_import_directive_groups = false
dotnet_sort_system_directives_first = true
csharp_using_directive_placement = outside_namespace:error

# Language keywords vs framework types
dotnet_diagnostic.IDE0049.severity = error  # Use language keywords (int vs Int32)

# Modifier preferences
dotnet_diagnostic.IDE0036.severity = error  # Order modifiers
dotnet_diagnostic.IDE0040.severity = error  # Add accessibility modifiers
csharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async:error

# SDK-specific naming convention exceptions (Grasshopper 'DA', Rhino 'UV'/'XYZ')
dotnet_diagnostic.IDE1006.severity = none  # Allow SDK naming conventions
resharper_inconsistent_naming_highlighting = none

# EXPLICIT TYPING ENFORCEMENT - ERROR
# No var allowed anywhere per standards.md requirement

csharp_style_var_for_built_in_types = false:error  # NEVER use var for int, string, double, etc.
csharp_style_var_when_type_is_apparent = false:error  # NEVER use var even when type is obvious
csharp_style_var_elsewhere = false:error  # NEVER use var anywhere
dotnet_diagnostic.IDE0007.severity = none  # Don't suggest implicit type - CONFLICT RESOLVED: Disabled in favor of IDE0008
dotnet_diagnostic.IDE0008.severity = error  # Enforce explicit type - PRIMARY RULE: Enforces standards.md no-var policy

# MODERN C# FEATURES - ERROR
# Collection expressions, pattern matching, null-coalescing operators

# Collection expressions (C# 12 - MANDATORY)
dotnet_style_prefer_collection_expression = true:error
dotnet_diagnostic.IDE0300.severity = error  # Use collection expression for array
dotnet_diagnostic.IDE0301.severity = error  # Use collection expression for empty
dotnet_diagnostic.IDE0302.severity = error  # Use collection expression for stackalloc
dotnet_diagnostic.IDE0303.severity = error  # Use collection expression for Create()
dotnet_diagnostic.IDE0304.severity = error  # Use collection expression for builder
dotnet_diagnostic.IDE0305.severity = error  # Use collection expression for fluent

# Pattern matching (C# 8+ - MANDATORY)
csharp_style_pattern_matching_over_is_with_cast_check = true:error
csharp_style_pattern_matching_over_as_with_null_check = true:error
csharp_style_prefer_pattern_matching = true:error
csharp_style_prefer_not_pattern = true:error
csharp_style_prefer_extended_property_pattern = true:warning
dotnet_diagnostic.IDE0019.severity = error  # Use pattern matching to avoid 'as' followed by null check
dotnet_diagnostic.IDE0020.severity = error  # Use pattern matching to avoid 'is' check followed by cast
dotnet_diagnostic.IDE0038.severity = error  # Use pattern matching to avoid 'is' check followed by cast (in expression)
dotnet_diagnostic.IDE0066.severity = error  # Use switch expression
dotnet_diagnostic.IDE0078.severity = error  # Use pattern matching
dotnet_diagnostic.IDE0083.severity = error  # Use pattern matching (not pattern)
dotnet_diagnostic.IDE0170.severity = warning  # Simplify property pattern
dotnet_diagnostic.IDE0260.severity = error  # Use pattern matching
dotnet_diagnostic.IDE0270.severity = error  # Use coalesce expression (null check)

# Null-checking and safety
dotnet_diagnostic.IDE0029.severity = error  # Use coalesce expression (non-nullable types)
dotnet_diagnostic.IDE0030.severity = error  # Use coalesce expression (nullable types)
dotnet_diagnostic.IDE0031.severity = error  # Use null propagation
dotnet_diagnostic.IDE0041.severity = error  # Use 'is null' check
dotnet_diagnostic.IDE0150.severity = error  # Prefer 'null' check over type check

# Switch expressions and exhaustiveness
dotnet_diagnostic.IDE0010.severity = error  # Add missing cases to switch statement
dotnet_diagnostic.IDE0072.severity = error  # Add missing cases to switch expression
dotnet_diagnostic.IDE0080.severity = error  # Remove unnecessary suppression operator
dotnet_diagnostic.IDE0082.severity = error  # Convert typeof to nameof

# Range and index operators (C# 8+)
dotnet_diagnostic.IDE0056.severity = warning  # Use index operator
dotnet_diagnostic.IDE0057.severity = warning  # Use range operator

# Target-typed new expressions (C# 9+)
csharp_style_implicit_object_creation_when_type_is_apparent = true:warning
dotnet_diagnostic.IDE0090.severity = warning  # Simplify new expression

# Using declarations (C# 8+)
csharp_prefer_simple_using_statement = true:warning
dotnet_diagnostic.IDE0063.severity = warning  # Use simple using statement

# Object and collection initializers
dotnet_diagnostic.IDE0017.severity = warning  # Use object initializers
dotnet_diagnostic.IDE0028.severity = warning  # Use collection initializers
dotnet_diagnostic.IDE0033.severity = warning  # Use explicitly provided tuple name
dotnet_diagnostic.IDE0037.severity = warning  # Use inferred member name

# String interpolation
dotnet_diagnostic.IDE0071.severity = warning  # Simplify interpolation
dotnet_diagnostic.IDE0070.severity = warning  # Use System.HashCode.Combine

# Primary constructors (C# 12)
csharp_style_prefer_primary_constructors = true:suggestion
dotnet_diagnostic.IDE0290.severity = suggestion  # Use primary constructor

# Local functions
dotnet_diagnostic.IDE0062.severity = warning  # Make local function static

# Deconstruction
dotnet_diagnostic.IDE0042.severity = suggestion  # Deconstruct variable declaration

# SOLID PRINCIPLES - ERROR
# Single responsibility, sealed classes, interface segregation
# SEVERITY RATIONALE: All SOLID principle violations are ERROR level per standards.md requirements

# Single Responsibility Principle (complexity limits)
dotnet_diagnostic.CA1501.severity = error  # Avoid excessive inheritance (max depth: 5)
dotnet_code_quality.CA1501.max_inheritance_depth = 5  # Maximum inheritance depth
dotnet_diagnostic.CA1502.severity = error  # Avoid excessive complexity (cyclomatic complexity)
dotnet_diagnostic.CA1505.severity = error  # Avoid unmaintainable code (maintainability index)
dotnet_diagnostic.CA1506.severity = error  # Avoid excessive class coupling
dotnet_diagnostic.S3776.severity = error  # Cognitive complexity should not be too high
dotnet_code_quality.S3776.threshold = 15  # Maximum cognitive complexity per method
dotnet_diagnostic.S1541.severity = error  # Cyclomatic complexity should not be too high - ELEVATED: Critical for maintainability
dotnet_code_quality.S1541.threshold = 10  # Maximum cyclomatic complexity
dotnet_diagnostic.S138.severity = none  # Functions should not have too many lines - CONFLICT RESOLVED: Disabled in favor of MA0051 (more configurable)
dotnet_code_quality.S138.max = 60  # Maximum lines per method (disabled but kept for reference)
dotnet_diagnostic.S1448.severity = error  # Classes should not have too many public methods
dotnet_code_quality.S1448.max = 15  # Maximum public members per class
dotnet_diagnostic.S134.severity = error  # Control flow statements should not be nested too deeply
dotnet_code_quality.S134.max = 3  # Maximum nesting depth
dotnet_diagnostic.S1200.severity = error  # Classes should not be coupled to too many other classes
dotnet_code_quality.S1200.max = 20  # Maximum coupling (dependencies)

# Open/Closed Principle (sealed classes by default)
dotnet_diagnostic.CA1052.severity = error  # Static holder types should be sealed
dotnet_diagnostic.CA1852.severity = error  # Seal internal types - PRIMARY RULE: Enforces standards.md sealed-by-default policy
dotnet_diagnostic.CA1053.severity = error  # Static holder types should not have constructors

# Liskov Substitution Principle
dotnet_diagnostic.CA1012.severity = error  # Abstract types should not have public constructors
dotnet_diagnostic.CA1061.severity = error  # Do not hide base class methods
dotnet_diagnostic.CA1063.severity = error  # Implement IDisposable correctly
dotnet_diagnostic.CA1064.severity = error  # Exceptions should be public
dotnet_diagnostic.CA1065.severity = error  # Do not raise exceptions in unexpected locations
dotnet_diagnostic.CA1066.severity = warning  # Implement IEquatable when overriding Equals
dotnet_diagnostic.CA1067.severity = error  # Override Equals when implementing IEquatable
dotnet_diagnostic.CA1068.severity = error  # CancellationToken parameters must come last
dotnet_diagnostic.CA1069.severity = error  # Enums should not have duplicate values
dotnet_diagnostic.CA1070.severity = warning  # Do not declare event fields as virtual

# Interface Segregation Principle
dotnet_diagnostic.CA1010.severity = error  # Collections should implement generic interface
dotnet_diagnostic.CA1040.severity = error  # Avoid empty interfaces
dotnet_diagnostic.CA1043.severity = warning  # Use integral or string argument for indexers
dotnet_diagnostic.CA1044.severity = warning  # Properties should not be write only
dotnet_diagnostic.CA1047.severity = error  # Do not declare protected members in sealed types
dotnet_diagnostic.CA1051.severity = error  # Do not declare visible instance fields

# Dependency Inversion Principle
dotnet_diagnostic.CA1050.severity = error  # Declare types in namespaces (MANDATORY)

# Additional SOLID enforcement
dotnet_diagnostic.CA1000.severity = warning  # Do not declare static members on generic types
dotnet_diagnostic.CA1008.severity = warning  # Enums should have zero value
dotnet_diagnostic.CA1016.severity = none  # FIXED: Don't require AssemblyVersion attribute for library projects
dotnet_diagnostic.CA1027.severity = warning  # Mark enums with FlagsAttribute
dotnet_diagnostic.CA1024.severity = warning  # Use properties where appropriate
dotnet_diagnostic.CA1033.severity = warning  # Interface methods should be callable by child types
dotnet_diagnostic.CA1034.severity = none  # Nested types should not be visible (allow for Result<T>.ErrorInfo)

# FUNCTIONAL PROGRAMMING - ERROR
# Immutability, pure functions, readonly enforcement
# SEVERITY RATIONALE: Functional programming violations are ERROR level per standards.md requirements

# Immutability enforcement
dotnet_diagnostic.IDE0044.severity = error  # Add readonly modifier (immutability)
dotnet_diagnostic.CA2227.severity = error  # Collection properties should be read only - ELEVATED: Critical for immutability
dotnet_diagnostic.CA1805.severity = warning  # Do not initialize unnecessarily
dotnet_diagnostic.CA1819.severity = error  # Properties should not return arrays - ELEVATED: Critical for immutability (prefer IReadOnlyList)

# Pure function patterns
dotnet_diagnostic.CA1822.severity = error  # Mark members as static (pure functions) - ELEVATED: Critical for functional design

# Record types and value equality
dotnet_diagnostic.IDE0050.severity = warning  # Convert anonymous type to tuple
dotnet_diagnostic.CA1815.severity = error  # Override Equals and operator == on value types

# Higher-order functions and LINQ
dotnet_diagnostic.CA1826.severity = error  # Use property instead of Linq Enumerable method - PRIMARY RULE: Comprehensive LINQ optimization
dotnet_diagnostic.CA1827.severity = error  # Do not use Count/LongCount when Any can be used
dotnet_diagnostic.CA1828.severity = error  # Do not use CountAsync/LongCountAsync when AnyAsync can be used
dotnet_diagnostic.CA1829.severity = error  # Use Length/Count property instead of Enumerable.Count
dotnet_diagnostic.CA1851.severity = error  # Possible multiple enumerations of IEnumerable collection
dotnet_diagnostic.CA1860.severity = error  # Avoid using Enumerable.Any() extension method

# PERFORMANCE - WARNING
# Memory optimization, Span/Memory, string operations, LINQ optimization

# Memory and allocation optimization
dotnet_diagnostic.CA1825.severity = warning  # Avoid zero-length array allocations
dotnet_diagnostic.CA1830.severity = warning  # Prefer strongly-typed Append and Insert method overloads on StringBuilder
dotnet_diagnostic.CA1831.severity = warning  # Use AsSpan instead of Range-based indexers for string when appropriate
dotnet_diagnostic.CA1832.severity = warning  # Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array
dotnet_diagnostic.CA1833.severity = warning  # Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array
dotnet_diagnostic.CA1834.severity = warning  # Use StringBuilder.Append(char) for single character strings
dotnet_diagnostic.CA1835.severity = warning  # Prefer the memory-based overloads of ReadAsync/WriteAsync methods in stream-based classes
dotnet_diagnostic.CA1836.severity = warning  # Prefer IsEmpty over Count when available
dotnet_diagnostic.CA1837.severity = warning  # Use Environment.ProcessId instead of Process.GetCurrentProcess().Id
dotnet_diagnostic.CA1838.severity = warning  # Avoid StringBuilder parameters for P/Invokes
dotnet_diagnostic.CA1839.severity = warning  # Use Environment.ProcessPath instead of Process.GetCurrentProcess().MainModule.FileName
dotnet_diagnostic.CA1840.severity = warning  # Use Environment.CurrentManagedThreadId instead of Thread.CurrentThread.ManagedThreadId
dotnet_diagnostic.CA1841.severity = warning  # Prefer Dictionary Contains methods
dotnet_diagnostic.CA1842.severity = warning  # Do not use WhenAll with a single task
dotnet_diagnostic.CA1843.severity = warning  # Do not use WhenAny with a single task
dotnet_diagnostic.CA1844.severity = warning  # Provide memory-based overrides of async methods when subclassing Stream
dotnet_diagnostic.CA1845.severity = warning  # Use span-based string.Concat
dotnet_diagnostic.CA1846.severity = warning  # Prefer AsSpan over Substring
dotnet_diagnostic.CA1847.severity = warning  # Use string.Contains(char) instead of string.Contains(string) with single characters
dotnet_diagnostic.CA1848.severity = warning  # Use the LoggerMessage delegates
dotnet_diagnostic.CA1849.severity = warning  # Call async methods when in an async method
dotnet_diagnostic.CA1850.severity = warning  # Prefer static HashData method over ComputeHash
dotnet_diagnostic.CA1853.severity = warning  # Unnecessary call to Dictionary.ContainsKey(key)
dotnet_diagnostic.CA1854.severity = warning  # Prefer the IDictionary.TryGetValue(TKey, out TValue) method
dotnet_diagnostic.CA1855.severity = warning  # Use Span<T>.Clear() instead of Span<T>.Fill()
dotnet_diagnostic.CA1856.severity = warning  # Incorrect usage of ConstantExpected attribute
dotnet_diagnostic.CA1857.severity = warning  # Use ConstantExpected attribute for parameters
dotnet_diagnostic.CA1858.severity = warning  # Use StartsWith instead of IndexOf
dotnet_diagnostic.CA1859.severity = warning  # Use concrete types when possible for improved performance
dotnet_diagnostic.CA1861.severity = warning  # Avoid constant arrays as arguments
dotnet_diagnostic.CA1862.severity = warning  # Use the StringComparison method overloads to perform case-insensitive string comparisons
dotnet_diagnostic.CA1863.severity = warning  # Use composite format
dotnet_diagnostic.CA1864.severity = warning  # Prefer the IDictionary.TryAdd(TKey, TValue) method
dotnet_diagnostic.CA1865.severity = warning  # Use char overload
dotnet_diagnostic.CA1866.severity = warning  # Use char overload
dotnet_diagnostic.CA1867.severity = warning  # Use char overload
dotnet_diagnostic.CA1868.severity = warning  # Unnecessary call to Contains for sets
dotnet_diagnostic.CA1869.severity = warning  # Cache and reuse JsonSerializerOptions instances
dotnet_diagnostic.CA1870.severity = warning  # Use a cached SearchValues instance

# Meziantou Analyzer - String comparison and culture-awareness
dotnet_diagnostic.MA0001.severity = error  # StringComparison is missing - PRIMARY RULE: Comprehensive string comparison enforcement
dotnet_diagnostic.MA0002.severity = error  # IEqualityComparer or IComparer is missing
dotnet_diagnostic.MA0006.severity = error  # Use String.Equals instead of equality operator
dotnet_diagnostic.MA0011.severity = error  # IFormatProvider is missing
dotnet_diagnostic.MA0021.severity = error  # Use StringComparer.GetHashCode instead of string.GetHashCode
dotnet_diagnostic.MA0024.severity = error  # Use an explicit StringComparer when possible
dotnet_diagnostic.MA0074.severity = error  # Avoid implicit culture-sensitive methods
dotnet_diagnostic.MA0075.severity = warning  # Do not use implicit culture-sensitive ToString
dotnet_diagnostic.MA0076.severity = warning  # Do not use implicit culture-sensitive ToString in interpolated strings

# Meziantou Analyzer - StringBuilder and string optimization
dotnet_diagnostic.MA0028.severity = error  # Optimize StringBuilder usage
dotnet_diagnostic.MA0089.severity = error  # Optimize string method usage

# Meziantou Analyzer - Array and collection optimization
dotnet_diagnostic.MA0005.severity = error  # Use Array.Empty()
dotnet_diagnostic.MA0020.severity = warning  # Use direct methods instead of LINQ methods
dotnet_diagnostic.MA0029.severity = warning  # Combine LINQ methods
dotnet_diagnostic.MA0030.severity = warning  # Remove useless OrderBy call
dotnet_diagnostic.MA0031.severity = none  # Optimize Enumerable.Count() usage - CONFLICT RESOLVED: Disabled in favor of CA1827/CA1829 (more comprehensive)
dotnet_diagnostic.MA0063.severity = warning  # Use Where before OrderBy
dotnet_diagnostic.MA0078.severity = warning  # Use 'Cast' instead of 'Select' to cast
dotnet_diagnostic.MA0098.severity = warning  # Use indexer instead of LINQ methods
dotnet_diagnostic.MA0103.severity = error  # Use SequenceEqual instead of equality operator
dotnet_diagnostic.MA0112.severity = none  # Use 'Count > 0' instead of 'Any()' - CONFLICT RESOLVED: Disabled in favor of CA1860 (stricter Any() enforcement)
dotnet_diagnostic.MA0128.severity = warning  # Use 'is' operator instead of SequenceEqual
dotnet_diagnostic.MA0159.severity = warning  # Use 'Order' instead of 'OrderBy'
dotnet_diagnostic.MA0160.severity = warning  # Use ContainsKey instead of TryGetValue

# Meziantou Analyzer - Struct layout and performance
dotnet_diagnostic.MA0008.severity = warning  # Add StructLayoutAttribute
dotnet_diagnostic.MA0102.severity = warning  # Make member readonly
dotnet_diagnostic.MA0109.severity = suggestion  # Consider adding an overload with a Span or Memory
dotnet_diagnostic.MA0168.severity = suggestion  # Use readonly struct for in or ref readonly parameter

# Meziantou Analyzer - Value type equality and hashing
dotnet_diagnostic.MA0065.severity = warning  # Default ValueType.Equals or HashCode is used for struct equality
dotnet_diagnostic.MA0066.severity = warning  # Hash table unfriendly type is used in a hash table
dotnet_diagnostic.MA0077.severity = error  # A class that provides Equals(T) should implement IEquatable

# ASYNC PATTERNS - ERROR
# ConfigureAwait, CancellationToken propagation, async naming
# SEVERITY RATIONALE: Async violations are ERROR level per standards.md requirements for professional async patterns

# ConfigureAwait enforcement (MANDATORY for library code)
dotnet_diagnostic.MA0004.severity = error  # Use Task.ConfigureAwait - PRIMARY RULE: Comprehensive ConfigureAwait enforcement
dotnet_diagnostic.CA2007.severity = none  # ConfigureAwait - CONFLICT RESOLVED: Disabled in favor of MA0004 (more comprehensive)

# Async method patterns
dotnet_diagnostic.MA0022.severity = error  # Return Task.FromResult instead of returning null
dotnet_diagnostic.MA0042.severity = error  # Do not use blocking calls in an async method
dotnet_diagnostic.MA0045.severity = error  # Do not use blocking calls in a sync method - ELEVATED: Critical async pattern violation
dotnet_diagnostic.MA0100.severity = error  # Await task before disposing of resources
dotnet_diagnostic.MA0129.severity = error  # Await task in using statement
dotnet_diagnostic.MA0134.severity = error  # Observe result of async calls
dotnet_diagnostic.MA0147.severity = error  # Avoid async void method for delegate
dotnet_diagnostic.MA0155.severity = error  # Do not use async void methods

# CancellationToken propagation
dotnet_diagnostic.MA0032.severity = error  # Use an overload with a CancellationToken argument - ELEVATED: Critical for proper cancellation
dotnet_diagnostic.MA0040.severity = error  # Forward the CancellationToken parameter - PRIMARY RULE: Comprehensive CancellationToken forwarding
dotnet_diagnostic.MA0079.severity = error  # Forward the CancellationToken using .WithCancellation()
dotnet_diagnostic.MA0080.severity = error  # Use a cancellation token using .WithCancellation() - ELEVATED: Critical for proper cancellation
dotnet_diagnostic.CA2016.severity = none  # Forward CancellationToken parameter - CONFLICT RESOLVED: Disabled in favor of MA0040 (more comprehensive)

# Async naming conventions
dotnet_diagnostic.MA0137.severity = warning  # Use 'Async' suffix when a method returns an awaitable type
dotnet_diagnostic.MA0138.severity = warning  # Do not use 'Async' suffix when a method does not return an awaitable type
dotnet_diagnostic.MA0156.severity = warning  # Use 'Async' suffix when a method returns IAsyncEnumerable
dotnet_diagnostic.MA0157.severity = warning  # Do not use 'Async' suffix when a method returns IAsyncEnumerable

# Async optimization
dotnet_diagnostic.MA0152.severity = warning  # Use Unwrap instead of using await twice

# SECURITY - ERROR
# Credentials, cryptography, injection prevention, network security

# Credentials and secrets
dotnet_diagnostic.S2068.severity = error  # Credentials should not be hard-coded
dotnet_diagnostic.S6418.severity = error  # Hard-coded secrets should not be used

# Cryptography and random number generation
dotnet_diagnostic.S2245.severity = error  # Using pseudorandom number generators (PRNGs) is security-sensitive
dotnet_diagnostic.S4426.severity = error  # Cryptographic keys should be robust
dotnet_diagnostic.S5042.severity = error  # Expanding archive files without controlling resource consumption is security-sensitive
dotnet_diagnostic.S4790.severity = error  # Using weak hashing algorithms is security-sensitive
dotnet_diagnostic.S5547.severity = error  # Cipher algorithms should be robust
dotnet_diagnostic.CA5350.severity = error  # Do Not Use Weak Cryptographic Algorithms
dotnet_diagnostic.CA5351.severity = error  # Do Not Use Broken Cryptographic Algorithms
dotnet_diagnostic.CA5385.severity = error  # Use Rivest–Shamir–Adleman (RSA) algorithm with sufficient key size
dotnet_diagnostic.CA5397.severity = error  # Do not use deprecated SslProtocols values

# HTTP and network security
dotnet_diagnostic.S3330.severity = error  # HTTP cookies should be "secure"
dotnet_diagnostic.S5332.severity = error  # Using clear-text protocols is security-sensitive
dotnet_diagnostic.S4423.severity = error  # Weak SSL/TLS protocols should not be used
dotnet_diagnostic.S5122.severity = error  # Having a permissive Cross-Origin Resource Sharing policy is security-sensitive

# Injection vulnerabilities
dotnet_diagnostic.S2091.severity = error  # XPath expressions should not be vulnerable to injection attacks
dotnet_diagnostic.S2631.severity = error  # Regular expressions should not be vulnerable to Denial of Service attacks
dotnet_diagnostic.S3649.severity = error  # Database queries should not be vulnerable to injection attacks
dotnet_diagnostic.S5131.severity = error  # Endpoints should not be vulnerable to authorization bypass
dotnet_diagnostic.CA3001.severity = warning  # Review code for SQL injection vulnerabilities
dotnet_diagnostic.CA3002.severity = warning  # Review code for XSS vulnerabilities
dotnet_diagnostic.CA3003.severity = warning  # Review code for file path injection vulnerabilities
dotnet_diagnostic.CA3004.severity = warning  # Review code for information disclosure vulnerabilities
dotnet_diagnostic.CA3005.severity = warning  # Review code for LDAP injection vulnerabilities
dotnet_diagnostic.CA3006.severity = warning  # Review code for process command injection vulnerabilities
dotnet_diagnostic.CA3007.severity = warning  # Review code for open redirect vulnerabilities
dotnet_diagnostic.CA3008.severity = warning  # Review code for XPath injection vulnerabilities
dotnet_diagnostic.CA3009.severity = warning  # Review code for XML injection vulnerabilities
dotnet_diagnostic.CA3010.severity = warning  # Review code for XAML injection vulnerabilities
dotnet_diagnostic.CA3011.severity = warning  # Review code for DLL injection vulnerabilities
dotnet_diagnostic.CA3012.severity = warning  # Review code for regex injection vulnerabilities

# Additional security rules
dotnet_diagnostic.S4507.severity = error  # Delivering code in production with debug features activated is security-sensitive
dotnet_diagnostic.S5659.severity = error  # JWT should be signed and verified
dotnet_diagnostic.S6377.severity = error  # XML signatures should be validated securely

# Logic and control flow vulnerabilities
dotnet_diagnostic.S2583.severity = error  # Conditionally executed code should be reachable
dotnet_diagnostic.S2589.severity = warning  # Boolean expressions should not be gratuitous

# CODE QUALITY - ERROR
# Complexity limits, LOC limits, dead code, duplicate code

# Method length enforcement (60 lines max per method, aligns with standards.md)
dotnet_diagnostic.MA0051.severity = error  # Method is too long - PRIMARY RULE: Enforces standards.md 60-line method limit
dotnet_diagnostic.MA0051.max_lines = 60  # Maximum 60 lines per method

# Duplicate code detection (ZERO TOLERANCE per standards.md)
dotnet_diagnostic.S1192.severity = error  # String literals should not be duplicated
dotnet_code_quality.S1192.threshold = 3  # Minimum occurrences to trigger
dotnet_diagnostic.S4144.severity = error  # Methods should not have identical implementations
dotnet_diagnostic.S2326.severity = error  # Unused type parameters should be removed

# Dead code detection (MANDATORY cleanup)
dotnet_diagnostic.S1144.severity = warning  # LOWERED: Unused private types or members (allow for library APIs)
dotnet_diagnostic.S1481.severity = error  # Unused local variables should be removed
dotnet_diagnostic.S1854.severity = warning  # Unused assignments should be removed
dotnet_diagnostic.S1172.severity = warning  # Unused method parameters should be removed
dotnet_diagnostic.IDE0051.severity = none  # Remove unused private member - CONFLICT RESOLVED: Disabled in favor of S1144 (more comprehensive)
dotnet_diagnostic.IDE0052.severity = none  # Remove unread private member - CONFLICT RESOLVED: Disabled in favor of S1144 (more comprehensive)
dotnet_diagnostic.CA1812.severity = none  # Class is never used (allow for library code)

# Empty blocks and statements
dotnet_diagnostic.S108.severity = error  # Nested blocks of code should not be left empty
dotnet_diagnostic.S1186.severity = error  # Methods should not be empty
dotnet_diagnostic.S2699.severity = warning  # Tests should include assertions

# Code organization and clarity
dotnet_diagnostic.S1066.severity = warning  # Mergeable if statements should be combined
dotnet_diagnostic.S1067.severity = warning  # Expressions should not be too complex
dotnet_code_quality.S1067.max = 3  # Maximum boolean operators per expression
dotnet_diagnostic.S1125.severity = warning  # Boolean literals should not be redundant
dotnet_diagnostic.S1135.severity = suggestion  # Track uses of TODO tags
dotnet_diagnostic.S1199.severity = warning  # Nested code blocks should not be used

# Magic numbers and hardcoded values
dotnet_diagnostic.S109.severity = warning  # Magic numbers should not be used
dotnet_diagnostic.S1075.severity = warning  # URIs should not be hardcoded

# Utility class design
dotnet_diagnostic.S1118.severity = error  # Utility classes should not have public constructors

# Exception handling patterns
dotnet_diagnostic.S2737.severity = error  # Catch clauses should do more than rethrow
dotnet_diagnostic.S1166.severity = error  # Exception handlers should preserve stack trace
dotnet_diagnostic.S2139.severity = warning  # Exceptions should not be thrown from property getters
dotnet_diagnostic.S2221.severity = error  # "Exception" should not be caught when not required by called methods
dotnet_diagnostic.CA1031.severity = none  # Catch general exceptions (allow for error handling pattern)

# Meziantou Analyzer - Class design and architecture
dotnet_diagnostic.MA0017.severity = error  # Abstract types should not have public or internal constructors
dotnet_diagnostic.MA0036.severity = warning  # Make class static
dotnet_diagnostic.MA0053.severity = none  # Make class sealed - CONFLICT RESOLVED: Disabled in favor of CA1852 (more comprehensive)
dotnet_diagnostic.MA0056.severity = error  # Do not call overridable members in constructor

# Meziantou Analyzer - Exception handling patterns
dotnet_diagnostic.MA0012.severity = error  # Do not raise reserved exception type
dotnet_diagnostic.MA0013.severity = error  # Types should not extend System.ApplicationException
dotnet_diagnostic.MA0014.severity = error  # Do not raise System.ApplicationException type
dotnet_diagnostic.MA0015.severity = error  # Specify the parameter name in ArgumentException
dotnet_diagnostic.MA0025.severity = error  # Implement the functionality instead of throwing NotImplementedException
dotnet_diagnostic.MA0027.severity = error  # Prefer rethrowing an exception implicitly
dotnet_diagnostic.MA0043.severity = warning  # Use nameof operator in ArgumentException
dotnet_diagnostic.MA0054.severity = error  # Embed the caught exception as innerException
dotnet_diagnostic.MA0072.severity = error  # Do not throw from a finally block
dotnet_diagnostic.MA0086.severity = error  # Do not throw from a finalizer

# Meziantou Analyzer - Interface and abstraction design
dotnet_diagnostic.MA0016.severity = warning  # Prefer using collection abstraction instead of implementation
dotnet_diagnostic.MA0094.severity = error  # A class that provides CompareTo(T) should implement IComparable
dotnet_diagnostic.MA0095.severity = error  # A class that implements IEquatable should override Equals(object)
dotnet_diagnostic.MA0096.severity = error  # A class that implements IComparable should also implement IEquatable
dotnet_diagnostic.MA0097.severity = error  # A class that implements IComparable or IComparable should override comparison operators

# Meziantou Analyzer - Finalizer and disposal patterns
dotnet_diagnostic.MA0055.severity = error  # Do not use finalizer

# Resource management and disposal
dotnet_diagnostic.CA2000.severity = warning  # Dispose objects before losing scope
dotnet_diagnostic.CA2002.severity = warning  # Do not lock on objects with weak identity
dotnet_diagnostic.CA2008.severity = warning  # Do not create tasks without passing a TaskScheduler
dotnet_diagnostic.CA2009.severity = warning  # Do not call ToImmutableCollection on an ImmutableCollection value
dotnet_diagnostic.CA2011.severity = warning  # Do not assign property within its setter
dotnet_diagnostic.CA2012.severity = warning  # Use ValueTasks correctly
dotnet_diagnostic.CA2013.severity = warning  # Do not use ReferenceEquals with value types
dotnet_diagnostic.CA2014.severity = warning  # Do not use stackalloc in loops
dotnet_diagnostic.CA2015.severity = warning  # Do not define finalizers for types derived from MemoryManager<T>
dotnet_diagnostic.CA2017.severity = warning  # Parameter count mismatch
dotnet_diagnostic.CA2018.severity = warning  # Buffer.BlockCopy argument validation
dotnet_diagnostic.CA2019.severity = warning  # ThreadStatic fields should not use inline initialization
dotnet_diagnostic.CA2020.severity = warning  # Prevent from behavioral change

# NAMING CONVENTIONS - ERROR
# Interfaces, types, members, async naming
# SEVERITY RATIONALE: Naming violations are ERROR level per standards.md professional requirements

# Interface naming (I prefix mandatory)
dotnet_naming_rule.interface_should_be_begins_with_i.severity = error
dotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface
dotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i

# Type naming (PascalCase)
dotnet_naming_rule.types_should_be_pascal_case.severity = error
dotnet_naming_rule.types_should_be_pascal_case.symbols = types
dotnet_naming_rule.types_should_be_pascal_case.style = pascal_case

# Member naming (PascalCase)
dotnet_naming_rule.non_field_members_should_be_pascal_case.severity = error
dotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members
dotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case

# Symbol specifications
dotnet_naming_symbols.interface.applicable_kinds = interface
dotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.interface.required_modifiers = 

dotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum
dotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.types.required_modifiers = 

dotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method
dotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.non_field_members.required_modifiers = 

# Naming styles
dotnet_naming_style.pascal_case.required_prefix = 
dotnet_naming_style.pascal_case.required_suffix = 
dotnet_naming_style.pascal_case.word_separator = 
dotnet_naming_style.pascal_case.capitalization = pascal_case

dotnet_naming_style.begins_with_i.required_prefix = I
dotnet_naming_style.begins_with_i.required_suffix = 
dotnet_naming_style.begins_with_i.word_separator = 
dotnet_naming_style.begins_with_i.capitalization = pascal_case

# Meziantou Analyzer - Naming conventions
dotnet_diagnostic.MA0057.severity = error  # Class name should end with 'Attribute' - ELEVATED: Critical naming convention
dotnet_diagnostic.MA0058.severity = error  # Class name should end with 'Exception' - ELEVATED: Critical naming convention
dotnet_diagnostic.MA0059.severity = error  # Class name should end with 'EventArgs' - ELEVATED: Critical naming convention
dotnet_diagnostic.MA0048.severity = error  # File name must match type name
dotnet_diagnostic.MA0047.severity = error  # Declare types in namespaces
dotnet_diagnostic.MA0049.severity = error  # Type name should not match containing namespace
dotnet_diagnostic.MA0104.severity = error  # Do not create a type with a name from the BCL - ELEVATED: Critical naming conflict

# CA naming rules
dotnet_diagnostic.CA1715.severity = error  # Identifiers should have correct prefix (T prefix mandatory)
dotnet_diagnostic.CA1720.severity = error  # Identifiers should not contain type names
dotnet_diagnostic.CA1710.severity = error  # Identifiers should have correct suffix - ELEVATED: Critical naming convention
dotnet_diagnostic.CA1711.severity = error  # Identifiers should not have incorrect suffix - ELEVATED: Critical naming convention
dotnet_diagnostic.CA1712.severity = error  # Do not prefix enum values with type name - ELEVATED: Critical naming convention
dotnet_diagnostic.CA1713.severity = error  # Events should not have before or after prefix - ELEVATED: Critical naming convention
dotnet_diagnostic.CA1714.severity = error  # Flags enums should have plural names - ELEVATED: Critical naming convention
dotnet_diagnostic.CA1716.severity = error  # Identifiers should not match keywords - ELEVATED: Critical naming conflict
dotnet_diagnostic.CA1717.severity = error  # Only FlagsAttribute enums should have plural names - ELEVATED: Critical naming convention
dotnet_diagnostic.CA1721.severity = error  # Property names should not match get methods - ELEVATED: Critical naming conflict
dotnet_diagnostic.CA1724.severity = error  # Type names should not match namespaces - ELEVATED: Critical naming conflict
dotnet_diagnostic.CA1725.severity = error  # Parameter names should match base declaration - ELEVATED: Critical for polymorphism

# Meziantou Analyzer - Event patterns
dotnet_diagnostic.MA0019.severity = error  # Use EventArgs.Empty
dotnet_diagnostic.MA0046.severity = error  # Use EventHandler to declare events
dotnet_diagnostic.MA0091.severity = error  # Sender should be 'this' for instance events
dotnet_diagnostic.MA0092.severity = error  # Sender should be 'null' for static events
dotnet_diagnostic.MA0093.severity = error  # EventArgs should not be null
dotnet_diagnostic.MA0085.severity = error  # Anonymous delegates should not be used to unsubscribe from Events

# Meziantou Analyzer - Enum patterns
dotnet_diagnostic.MA0062.severity = error  # Non-flags enums should not be marked with "FlagsAttribute"
dotnet_diagnostic.MA0052.severity = warning  # Replace constant Enum.ToString with nameof
dotnet_diagnostic.MA0099.severity = error  # Use Explicit enum value instead of 0

# Meziantou Analyzer - Guid and DateTime usage
dotnet_diagnostic.MA0067.severity = warning  # Use Guid.Empty
dotnet_diagnostic.MA0113.severity = warning  # Use DateTime.UnixEpoch
dotnet_diagnostic.MA0114.severity = warning  # Use DateTimeOffset.UnixEpoch
dotnet_diagnostic.MA0132.severity = error  # Do not convert implicitly to DateTimeOffset
dotnet_diagnostic.MA0133.severity = warning  # Use DateTimeOffset instead of relying on the implicit conversion
dotnet_diagnostic.MA0176.severity = warning  # Optimize guid creation

# Meziantou Analyzer - Type checking and casting
dotnet_diagnostic.MA0130.severity = error  # GetType() should not be used on System.Type instances
dotnet_diagnostic.MA0131.severity = error  # ArgumentNullException.ThrowIfNull should not be used with non-nullable types
dotnet_diagnostic.MA0169.severity = error  # Use Equals method instead of operator

# Nullable reference types (CS8xxx warnings)
# SEVERITY RATIONALE: Null safety violations are ERROR level per standards.md requirements
dotnet_diagnostic.CS8600.severity = error  # Converting null literal or possible null value to non-nullable type - ELEVATED: Critical null safety
dotnet_diagnostic.CS8602.severity = error  # Dereference of a possibly null reference - ELEVATED: Critical null safety
dotnet_diagnostic.CS8603.severity = error  # Possible null reference return - ELEVATED: Critical null safety
dotnet_diagnostic.CS8604.severity = error  # Possible null reference argument - ELEVATED: Critical null safety

# Code style and organization
# SEVERITY RATIONALE: Style preferences remain at suggestion/none level per standards.md
dotnet_diagnostic.IDE0011.severity = suggestion  # Add braces - ELEVATED: Style preference for consistency
dotnet_diagnostic.IDE0058.severity = none  # Expression value is never used (allow)
dotnet_diagnostic.S3358.severity = none  # Nested ternary operators (allow for sophisticated functional patterns)

# Code cleanup and simplification
dotnet_diagnostic.IDE0001.severity = warning  # Simplify name
dotnet_diagnostic.IDE0002.severity = warning  # Simplify member access
dotnet_diagnostic.IDE0004.severity = warning  # Remove unnecessary cast
dotnet_diagnostic.IDE0035.severity = warning  # Remove unreachable code
dotnet_diagnostic.IDE0059.severity = warning  # Unnecessary assignment
dotnet_diagnostic.IDE0060.severity = warning  # Remove unused parameter
dotnet_diagnostic.IDE0079.severity = warning  # Remove unnecessary suppression
dotnet_diagnostic.IDE0100.severity = warning  # Remove unnecessary equality operator
dotnet_diagnostic.IDE0110.severity = warning  # Remove unnecessary discard

# Parentheses preferences
# SEVERITY RATIONALE: Parentheses are style preferences per standards.md
dotnet_diagnostic.IDE0047.severity = suggestion  # Remove unnecessary parentheses - ELEVATED: Style preference for consistency
dotnet_diagnostic.IDE0048.severity = suggestion  # Add parentheses for clarity - LOWERED: Style preference

# THIS/ME qualification (discouraged)
# SEVERITY RATIONALE: This/Me qualification is style preference per standards.md
dotnet_diagnostic.IDE0003.severity = suggestion  # Remove this or Me qualification - LOWERED: Style preference
dotnet_diagnostic.IDE0009.severity = none  # Add this or Me qualification (don't suggest)
dotnet_style_qualification_for_field = false:suggestion
dotnet_style_qualification_for_property = false:suggestion
dotnet_style_qualification_for_method = false:suggestion
dotnet_style_qualification_for_event = false:suggestion

# Inline declarations and simplifications
dotnet_diagnostic.IDE0018.severity = warning  # Inline variable declaration
dotnet_diagnostic.IDE0032.severity = warning  # Use auto property
dotnet_diagnostic.IDE0034.severity = warning  # Simplify default expression
dotnet_diagnostic.IDE0039.severity = warning  # Use local function instead of lambda
dotnet_diagnostic.IDE0045.severity = warning  # Use conditional expression for assignment
dotnet_diagnostic.IDE0046.severity = none  # Use conditional expression for return (allow if-else)
dotnet_diagnostic.IDE0055.severity = error  # Fix formatting (enforce consistent formatting)
dotnet_diagnostic.IDE0073.severity = none  # Require file header (not enforced)
dotnet_diagnostic.IDE0075.severity = warning  # Simplify conditional expression

# Expression-bodied members (style preferences)
# SEVERITY RATIONALE: Expression-bodied members are style preferences per standards.md - CONSISTENT: All set to suggestion for condensed/tight code style
dotnet_diagnostic.IDE0021.severity = suggestion  # Use expression body for constructors
dotnet_diagnostic.IDE0022.severity = suggestion  # Use expression body for methods
dotnet_diagnostic.IDE0023.severity = suggestion  # Use expression body for conversion operators
dotnet_diagnostic.IDE0024.severity = suggestion  # Use expression body for operators
dotnet_diagnostic.IDE0025.severity = suggestion  # Use expression body for properties
dotnet_diagnostic.IDE0026.severity = suggestion  # Use expression body for indexers
dotnet_diagnostic.IDE0027.severity = suggestion  # Use expression body for accessors
dotnet_diagnostic.IDE0053.severity = suggestion  # Use expression body for lambdas
dotnet_diagnostic.IDE0054.severity = warning  # Use compound assignment

# Meziantou Analyzer - Code simplification
# SEVERITY RATIONALE: Code readability suggestions remain at suggestion level per standards.md
dotnet_diagnostic.MA0003.severity = none  # FIXED: Don't enforce parameter naming for condensed code style
dotnet_diagnostic.MA0007.severity = suggestion  # Add a comma after the last value

# NullForgiving analyzer - Allow justified null-forgiving operators in Result<T> pattern
dotnet_diagnostic.NX0001.severity = none  # Allow null-forgiving operator in Result<T> implementation
dotnet_diagnostic.NX0002.severity = none  # Allow null-forgiving operator in Result<T> implementation

# Formatting preferences
csharp_new_line_before_open_brace = all
csharp_new_line_before_else = true
csharp_new_line_before_catch = true
csharp_new_line_before_finally = true
csharp_space_after_cast = false
csharp_space_after_keywords_in_control_flow_statements = true
csharp_preserve_single_line_blocks = true
csharp_preserve_single_line_statements = false

# Modern C# style preferences
# SEVERITY RATIONALE: File-scoped namespaces are ERROR per standards.md, others are style preferences
csharp_style_namespace_declarations = file_scoped:error  # CONFLICT RESOLVED: Elevated to error to match IDE0160/IDE0161 severity
csharp_style_prefer_method_group_conversion = true:warning
csharp_style_prefer_top_level_statements = false:suggestion
csharp_style_expression_bodied_methods = true:suggestion  # CONSISTENT: Prefer expression bodies for condensed/tight code style
csharp_style_expression_bodied_constructors = true:suggestion  # CONSISTENT: Prefer expression bodies for condensed/tight code style
csharp_style_expression_bodied_operators = true:suggestion  # CONSISTENT: Prefer expression bodies for condensed/tight code style
csharp_style_expression_bodied_properties = true:suggestion  # CONSISTENT: Prefer expression bodies for condensed/tight code style
csharp_style_expression_bodied_indexers = true:suggestion  # CONSISTENT: Prefer expression bodies for condensed/tight code style
csharp_style_expression_bodied_accessors = true:suggestion  # CONSISTENT: Prefer expression bodies for condensed/tight code style
