# ===================================================================
# PARAMETRIC ARSENAL - EDITORCONFIG
# Advanced Analyzer Enforcement Configuration
# ===================================================================
#
# This EditorConfig implements comprehensive code quality enforcement
# aligned with standards.md requirements:
#
# 1. INTERFACE-FIRST POLYMORPHIC DESIGN
#    - Sealed classes by default (CA1852)
#    - Interface segregation (CA1040, CA1010)
#    - Composition over inheritance (CA1501, CA1052)
#
# 2. MINIMAL LOC REQUIREMENTS
#    - 300-line hard limit per file
#    - Cyclomatic complexity limits (CA1502)
#    - Single responsibility enforcement (CA1506)
#
# 3. FUNCTIONAL PROGRAMMING INTEGRATION
#    - Immutability enforcement (IDE0044, CA2227)
#    - Pure function patterns (CA1822)
#    - Higher-order functions (LINQ optimization)
#
# 4. MODERN C# 12 / .NET 8 FEATURES
#    - File-scoped namespaces (MANDATORY)
#    - Collection expressions (MANDATORY)
#    - Pattern matching (MANDATORY)
#    - Explicit typing (NO VAR ALLOWED)
#
# 5. SOLID PRINCIPLES
#    - Single Responsibility (CA1502, CA1505, CA1506)
#    - Open/Closed (CA1852, sealed classes)
#    - Liskov Substitution (CA1012, CA1061, CA1067)
#    - Interface Segregation (CA1040, CA1010)
#    - Dependency Inversion (CA1050, interface-based design)
#
# All rules are set to ERROR or WARNING severity to enforce
# build-time quality gates. No compromises on code quality.
#
# ===================================================================

# Top-most EditorConfig file
root = true

# All files
[*]
charset = utf-8
insert_final_newline = true
trim_trailing_whitespace = true

# C# files
[*.cs]
indent_style = space
indent_size = 4

# Nullable reference types - enable warnings for proper null safety
# Library code should be defensive with nullable annotations
dotnet_diagnostic.CS8600.severity = warning  # Converting null literal or possible null value to non-nullable type
dotnet_diagnostic.CS8602.severity = warning  # Dereference of a possibly null reference
dotnet_diagnostic.CS8603.severity = warning  # Possible null reference return
dotnet_diagnostic.CS8604.severity = warning  # Possible null reference argument

# SDK-specific naming convention exceptions
# Grasshopper SDK convention: 'DA' parameter (uppercase) for IGH_DataAccess in SolveInstance methods
# Rhino SDK convention: Various uppercase abbreviations in parameter names (e.g., 'UV', 'XYZ')
# Rationale: Breaking SDK conventions would confuse users and break compatibility with SDK examples
dotnet_diagnostic.IDE1006.severity = none
resharper_inconsistent_naming_highlighting = none

# Unused using directives - enforce code cleanliness
dotnet_diagnostic.IDE0005.severity = warning

# "Class is never used" warnings - suppress for library code
# Rationale: Libraries provide functionality that may not be consumed yet
dotnet_diagnostic.IDE0051.severity = none
dotnet_diagnostic.CA1812.severity = none

# Modern C# 12 style preferences - enforce best practices
csharp_style_pattern_matching_over_is_with_cast_check = true:warning        # Use pattern matching over is with cast
csharp_style_pattern_matching_over_as_with_null_check = true:warning        # Use 'is not' pattern instead of 'as' + null check
dotnet_style_prefer_collection_expression = true:warning                    # Use collection expressions [...] instead of new[]

# Strong typing preferences - explicit types enforced for clarity and maintainability
csharp_style_var_for_built_in_types = false:warning             # Never use var for built-in types (int, string, double, etc.)
csharp_style_var_when_type_is_apparent = false:warning          # Never use var even when type is obvious from right-hand side
csharp_style_var_elsewhere = false:warning                      # Never use var anywhere - always explicit types

# Code style enforcement
dotnet_diagnostic.IDE0011.severity = none        # Add braces - disabled, prefer braceless for single statements
dotnet_diagnostic.IDE0058.severity = none        # Expression value is never used
dotnet_diagnostic.IDE0290.severity = warning     # Use primary constructor

# SonarAnalyzer - Advanced code patterns
dotnet_diagnostic.S3358.severity = none          # Nested ternary operators - allowed for sophisticated functional patterns

# ===================================================================
# MODERN C# 12 / .NET 8 IDE RULES - COMPREHENSIVE ENFORCEMENT
# ===================================================================

# ===================================================================
# FILE-SCOPED NAMESPACES (C# 10+) - MANDATORY
# Enforces file-scoped namespace declarations to reduce indentation
# and align with modern C# standards. This is a CRITICAL requirement
# per standards.md - all files MUST use file-scoped namespaces.
# ===================================================================
csharp_style_namespace_declarations = file_scoped:error
dotnet_diagnostic.IDE0160.severity = error       # Use file-scoped namespace (block to file-scoped)
dotnet_diagnostic.IDE0161.severity = error       # Use file-scoped namespace (file-scoped to block)

# ===================================================================
# EXPLICIT TYPING ENFORCEMENT (NO VAR) - MANDATORY
# Enforces explicit type declarations for all variables per standards.md.
# Professional code requires clarity - no implicit typing allowed.
# ===================================================================
csharp_style_var_for_built_in_types = false:error           # NEVER use var for int, string, double, etc.
csharp_style_var_when_type_is_apparent = false:error        # NEVER use var even when type is obvious
csharp_style_var_elsewhere = false:error                    # NEVER use var anywhere
dotnet_diagnostic.IDE0007.severity = none                   # Don't suggest implicit type
dotnet_diagnostic.IDE0008.severity = error                  # Enforce explicit type

# ===================================================================
# COLLECTION EXPRESSIONS (C# 12) - MANDATORY
# Enforces modern collection expression syntax [...] over legacy patterns.
# Collection expressions provide cleaner, more readable initialization.
# ===================================================================
dotnet_style_prefer_collection_expression = true:error
dotnet_diagnostic.IDE0300.severity = error       # Use collection expression for array
dotnet_diagnostic.IDE0301.severity = error       # Use collection expression for empty
dotnet_diagnostic.IDE0302.severity = error       # Use collection expression for stackalloc
dotnet_diagnostic.IDE0303.severity = error       # Use collection expression for Create()
dotnet_diagnostic.IDE0304.severity = error       # Use collection expression for builder
dotnet_diagnostic.IDE0305.severity = error       # Use collection expression for fluent

# ===================================================================
# PATTERN MATCHING (C# 8+) - MANDATORY
# Enforces pattern matching over legacy type checking and casting.
# Pattern matching is safer, more concise, and aligns with functional principles.
# ===================================================================
csharp_style_pattern_matching_over_is_with_cast_check = true:error
csharp_style_pattern_matching_over_as_with_null_check = true:error
csharp_style_prefer_pattern_matching = true:error
csharp_style_prefer_not_pattern = true:error
csharp_style_prefer_extended_property_pattern = true:warning
dotnet_diagnostic.IDE0019.severity = error       # Use pattern matching to avoid 'as' followed by null check
dotnet_diagnostic.IDE0020.severity = error       # Use pattern matching to avoid 'is' check followed by cast
dotnet_diagnostic.IDE0038.severity = error       # Use pattern matching to avoid 'is' check followed by cast (in expression)
dotnet_diagnostic.IDE0066.severity = error       # Use switch expression
dotnet_diagnostic.IDE0078.severity = error       # Use pattern matching
dotnet_diagnostic.IDE0083.severity = error       # Use pattern matching (not pattern)
dotnet_diagnostic.IDE0170.severity = warning     # Simplify property pattern
dotnet_diagnostic.IDE0260.severity = error       # Use pattern matching
dotnet_diagnostic.IDE0270.severity = error       # Use coalesce expression (null check)

# ===================================================================
# NULL-CHECKING AND SAFETY - MANDATORY
# Enforces modern null-checking patterns and null-conditional operators.
# Aligns with nullable reference types and defensive programming.
# ===================================================================
dotnet_diagnostic.IDE0029.severity = error       # Use coalesce expression (non-nullable types)
dotnet_diagnostic.IDE0030.severity = error       # Use coalesce expression (nullable types)
dotnet_diagnostic.IDE0031.severity = error       # Use null propagation
dotnet_diagnostic.IDE0041.severity = error       # Use 'is null' check
dotnet_diagnostic.IDE0150.severity = error       # Prefer 'null' check over type check

# ===================================================================
# SWITCH EXPRESSIONS AND EXHAUSTIVENESS - MANDATORY
# Enforces switch expressions over if-else chains and ensures exhaustive matching.
# Switch expressions are more functional and prevent missing cases.
# ===================================================================
dotnet_diagnostic.IDE0010.severity = error       # Add missing cases to switch statement
dotnet_diagnostic.IDE0072.severity = error       # Add missing cases to switch expression
dotnet_diagnostic.IDE0080.severity = error       # Remove unnecessary suppression operator
dotnet_diagnostic.IDE0082.severity = error       # Convert typeof to nameof

# ===================================================================
# MODERN C# FEATURE ADOPTION - REQUIRED
# Enforces adoption of modern C# features for cleaner, more maintainable code.
# ===================================================================

# Target-typed new expressions (C# 9+)
csharp_style_implicit_object_creation_when_type_is_apparent = true:warning
dotnet_diagnostic.IDE0090.severity = warning     # Simplify new expression

# Range and index operators (C# 8+)
dotnet_diagnostic.IDE0056.severity = warning     # Use index operator
dotnet_diagnostic.IDE0057.severity = warning     # Use range operator

# String interpolation
dotnet_diagnostic.IDE0071.severity = warning     # Simplify interpolation
dotnet_diagnostic.IDE0070.severity = warning     # Use System.HashCode.Combine

# Using declarations (C# 8+)
csharp_prefer_simple_using_statement = true:warning
dotnet_diagnostic.IDE0063.severity = warning     # Use simple using statement

# Primary constructors (C# 12)
csharp_style_prefer_primary_constructors = true:suggestion
dotnet_diagnostic.IDE0290.severity = suggestion  # Use primary constructor

# Local functions
dotnet_diagnostic.IDE0062.severity = warning     # Make local function static

# Deconstruction
dotnet_diagnostic.IDE0042.severity = suggestion  # Deconstruct variable declaration

# ===================================================================
# OBJECT AND COLLECTION INITIALIZERS - REQUIRED
# Enforces initializer syntax for cleaner object construction.
# ===================================================================
dotnet_diagnostic.IDE0017.severity = warning     # Use object initializers
dotnet_diagnostic.IDE0028.severity = warning     # Use collection initializers
dotnet_diagnostic.IDE0033.severity = warning     # Use explicitly provided tuple name
dotnet_diagnostic.IDE0037.severity = warning     # Use inferred member name

# ===================================================================
# EXPRESSION-BODIED MEMBERS - SUGGESTED
# Allows but doesn't require expression-bodied members.
# Use judgment based on readability - not all methods benefit from expression bodies.
# ===================================================================
dotnet_diagnostic.IDE0021.severity = suggestion  # Use expression body for constructors
dotnet_diagnostic.IDE0022.severity = suggestion  # Use expression body for methods
dotnet_diagnostic.IDE0023.severity = suggestion  # Use expression body for conversion operators
dotnet_diagnostic.IDE0024.severity = suggestion  # Use expression body for operators
dotnet_diagnostic.IDE0025.severity = suggestion  # Use expression body for properties
dotnet_diagnostic.IDE0026.severity = suggestion  # Use expression body for indexers
dotnet_diagnostic.IDE0027.severity = suggestion  # Use expression body for accessors
dotnet_diagnostic.IDE0053.severity = suggestion  # Use expression body for lambdas
dotnet_diagnostic.IDE0054.severity = warning     # Use compound assignment

# ===================================================================
# CODE ORGANIZATION AND CLEANUP - REQUIRED
# Enforces code organization standards and removes unnecessary code.
# ===================================================================

# Using directives
dotnet_diagnostic.IDE0005.severity = warning     # Remove unnecessary using directives
dotnet_diagnostic.IDE0065.severity = warning     # Using directive placement
dotnet_separate_import_directive_groups = false
dotnet_sort_system_directives_first = true
csharp_using_directive_placement = outside_namespace:error

# Language keywords vs framework types
dotnet_diagnostic.IDE0049.severity = error       # Use language keywords (int vs Int32)

# Parentheses preferences
dotnet_diagnostic.IDE0047.severity = none        # Remove unnecessary parentheses
dotnet_diagnostic.IDE0048.severity = warning     # Add parentheses for clarity

# Unnecessary code
dotnet_diagnostic.IDE0001.severity = warning     # Simplify name
dotnet_diagnostic.IDE0002.severity = warning     # Simplify member access
dotnet_diagnostic.IDE0004.severity = warning     # Remove unnecessary cast
dotnet_diagnostic.IDE0035.severity = warning     # Remove unreachable code
dotnet_diagnostic.IDE0051.severity = suggestion  # Remove unused private member
dotnet_diagnostic.IDE0052.severity = suggestion  # Remove unread private member
dotnet_diagnostic.IDE0058.severity = none        # Expression value is never used (allow)
dotnet_diagnostic.IDE0059.severity = warning     # Unnecessary assignment
dotnet_diagnostic.IDE0060.severity = warning     # Remove unused parameter
dotnet_diagnostic.IDE0079.severity = warning     # Remove unnecessary suppression
dotnet_diagnostic.IDE0080.severity = warning     # Remove unnecessary suppression operator
dotnet_diagnostic.IDE0100.severity = warning     # Remove unnecessary equality operator
dotnet_diagnostic.IDE0110.severity = warning     # Remove unnecessary discard

# ===================================================================
# MODIFIER PREFERENCES - REQUIRED
# Enforces consistent modifier ordering and accessibility declarations.
# Aligns with professional code standards and SOLID principles.
# ===================================================================
dotnet_diagnostic.IDE0036.severity = error       # Order modifiers
dotnet_diagnostic.IDE0040.severity = error       # Add accessibility modifiers
dotnet_diagnostic.IDE0044.severity = error       # Add readonly modifier (immutability)
csharp_preferred_modifier_order = public,private,protected,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async:error

# ===================================================================
# THIS/ME QUALIFICATION - DISCOURAGED
# Discourages 'this.' qualification except where necessary for disambiguation.
# Clean code should not require 'this.' prefix for clarity.
# ===================================================================
dotnet_diagnostic.IDE0003.severity = warning     # Remove this or Me qualification
dotnet_diagnostic.IDE0009.severity = none        # Add this or Me qualification (don't suggest)
dotnet_style_qualification_for_field = false:warning
dotnet_style_qualification_for_property = false:warning
dotnet_style_qualification_for_method = false:warning
dotnet_style_qualification_for_event = false:warning

# ===================================================================
# INLINE DECLARATIONS AND SIMPLIFICATIONS - REQUIRED
# Enforces inline variable declarations and code simplifications.
# ===================================================================
dotnet_diagnostic.IDE0018.severity = warning     # Inline variable declaration
dotnet_diagnostic.IDE0032.severity = warning     # Use auto property
dotnet_diagnostic.IDE0034.severity = warning     # Simplify default expression
dotnet_diagnostic.IDE0039.severity = warning     # Use local function instead of lambda
dotnet_diagnostic.IDE0045.severity = warning     # Use conditional expression for assignment
dotnet_diagnostic.IDE0046.severity = none        # Use conditional expression for return (allow if-else)
dotnet_diagnostic.IDE0050.severity = warning     # Convert anonymous type to tuple
dotnet_diagnostic.IDE0055.severity = error       # Fix formatting (enforce consistent formatting)
dotnet_diagnostic.IDE0073.severity = none        # Require file header (not enforced)
dotnet_diagnostic.IDE0075.severity = warning     # Simplify conditional expression

# ===================================================================
# ENHANCED RESHARPER INTEGRATION
# ===================================================================

# Variable declaration preferences
resharper_use_var_when_declaring_local_variable_severity = suggestion
resharper_for_built_in_types = use_explicit_type
resharper_for_simple_types = use_explicit_type
resharper_for_other_types = use_explicit_type

# Code arrangement and formatting
resharper_arrange_redundant_parentheses_highlighting = warning
resharper_arrange_this_qualifier_highlighting = hint
resharper_arrange_type_member_modifiers_highlighting = warning
resharper_arrange_type_modifiers_highlighting = warning
resharper_arrange_method_or_operator_body = suggestion
resharper_arrange_constructor_or_destructor_body = suggestion

# Null checking and safety
resharper_arrange_null_checking_pattern_highlighting = warning
resharper_convert_to_null_coalescing_compound_assignment_highlighting = warning
resharper_convert_null_coalescing_to_conditional_expression_highlighting = none

# Pattern matching
resharper_arrange_switch_expression_highlighting = warning
resharper_convert_switch_statement_to_expression_highlighting = warning
resharper_invert_if_highlighting = none

# String formatting and interpolation
resharper_arrange_string_interpolation_highlighting = warning
resharper_use_string_interpolation_highlighting = warning

# Collection and LINQ preferences
resharper_foreach_can_be_converted_to_query_using_another_get_enumerator_highlighting = none
resharper_foreach_can_be_partly_converted_to_query_using_another_get_enumerator_highlighting = none
resharper_loop_can_be_converted_to_query_highlighting = none
resharper_merge_sequential_checks_highlighting = warning

# Performance optimizations
resharper_merge_cast_with_type_check_highlighting = warning
resharper_unnecessary_whitespace_highlighting = warning
resharper_redundant_base_qualifier_highlighting = warning
resharper_redundant_explicit_array_creation_highlighting = warning

# Code quality inspections
resharper_suggest_var_or_type_built_in_types = use_explicit_type
resharper_suggest_var_or_type_simple_types = use_explicit_type
resharper_suggest_var_or_type_elsewhere = use_explicit_type
resharper_enforce_do_while_statement_braces = false
resharper_enforce_fixed_statement_braces = false
resharper_enforce_foreach_statement_braces = false
resharper_enforce_for_statement_braces = false
resharper_enforce_if_statement_braces = false
resharper_enforce_lock_statement_braces = false
resharper_enforce_using_statement_braces = false
resharper_enforce_while_statement_braces = false

# Access modifier preferences
resharper_redundant_default_member_initializer_highlighting = suggestion
resharper_class_never_instantiated_global_highlighting = hint
resharper_class_never_instantiated_local_highlighting = hint

# Async/await preferences
resharper_consider_using_config_await_highlighting = none
resharper_async_void_method_highlighting = warning

# ===================================================================
# SOLID PRINCIPLES & DESIGN RULES - COMPREHENSIVE ENFORCEMENT
# These rules enforce SOLID principles and composition-over-inheritance
# design patterns as mandated by standards.md and requirements.md.
# ===================================================================

# ===================================================================
# SINGLE RESPONSIBILITY PRINCIPLE (SRP)
# Classes should have one reason to change. Enforces low complexity,
# minimal coupling, and focused responsibilities.
# ===================================================================
dotnet_diagnostic.CA1501.severity = error        # Avoid excessive inheritance (max depth: 5)
dotnet_diagnostic.CA1502.severity = error        # Avoid excessive complexity (cyclomatic complexity)
dotnet_diagnostic.CA1505.severity = error        # Avoid unmaintainable code (maintainability index)
dotnet_diagnostic.CA1506.severity = error        # Avoid excessive class coupling
dotnet_diagnostic.CA1508.severity = warning      # Avoid dead conditional code
dotnet_diagnostic.CA1509.severity = warning      # Invalid entry in code metrics configuration

# ===================================================================
# OPEN/CLOSED PRINCIPLE (OCP)
# Open for extension via interfaces, closed for modification.
# Enforces sealed classes and interface-based extension.
# ===================================================================
dotnet_diagnostic.CA1052.severity = error        # Static holder types should be sealed
dotnet_diagnostic.CA1852.severity = error        # Seal internal types (CRITICAL for composition)
dotnet_diagnostic.CA1000.severity = warning      # Do not declare static members on generic types
dotnet_diagnostic.CA1008.severity = warning      # Enums should have zero value
dotnet_diagnostic.CA1027.severity = warning      # Mark enums with FlagsAttribute

# ===================================================================
# LISKOV SUBSTITUTION PRINCIPLE (LSP)
# Subtypes must be substitutable for base types without breaking contracts.
# Enforces proper inheritance hierarchies and interface contracts.
# ===================================================================
dotnet_diagnostic.CA1012.severity = error        # Abstract types should not have public constructors
dotnet_diagnostic.CA1024.severity = warning      # Use properties where appropriate
dotnet_diagnostic.CA1033.severity = warning      # Interface methods should be callable by child types
dotnet_diagnostic.CA1061.severity = error        # Do not hide base class methods
dotnet_diagnostic.CA1063.severity = error        # Implement IDisposable correctly
dotnet_diagnostic.CA1064.severity = error        # Exceptions should be public
dotnet_diagnostic.CA1065.severity = error        # Do not raise exceptions in unexpected locations
dotnet_diagnostic.CA1066.severity = warning      # Implement IEquatable when overriding Equals
dotnet_diagnostic.CA1067.severity = error        # Override Equals when implementing IEquatable
dotnet_diagnostic.CA1068.severity = error        # CancellationToken parameters must come last
dotnet_diagnostic.CA1069.severity = error        # Enums should not have duplicate values
dotnet_diagnostic.CA1070.severity = warning      # Do not declare event fields as virtual

# ===================================================================
# INTERFACE SEGREGATION PRINCIPLE (ISP)
# Clients should not depend on interfaces they don't use.
# Enforces small, focused interfaces over large, general ones.
# ===================================================================
dotnet_diagnostic.CA1010.severity = error        # Collections should implement generic interface
dotnet_diagnostic.CA1040.severity = error        # Avoid empty interfaces
dotnet_diagnostic.CA1041.severity = warning      # Provide ObsoleteAttribute message
dotnet_diagnostic.CA1043.severity = warning      # Use integral or string argument for indexers
dotnet_diagnostic.CA1044.severity = warning      # Properties should not be write only
dotnet_diagnostic.CA1045.severity = none         # Do not pass types by reference (allow for performance)
dotnet_diagnostic.CA1046.severity = warning      # Do not overload operator equals on reference types
dotnet_diagnostic.CA1047.severity = error        # Do not declare protected members in sealed types
dotnet_diagnostic.CA1051.severity = error        # Do not declare visible instance fields
dotnet_diagnostic.CA1054.severity = warning      # URI parameters should not be strings
dotnet_diagnostic.CA1055.severity = warning      # URI return values should not be strings
dotnet_diagnostic.CA1056.severity = warning      # URI properties should not be strings
dotnet_diagnostic.CA1058.severity = warning      # Types should not extend certain base types
dotnet_diagnostic.CA1060.severity = warning      # Move P/Invokes to NativeMethods class

# Nested types (allow for tightly-coupled value types like Result<T>.ErrorInfo)
dotnet_diagnostic.CA1034.severity = none         # Nested types should not be visible

# ===================================================================
# DEPENDENCY INVERSION PRINCIPLE (DIP)
# Depend on abstractions (interfaces), not concretions (classes).
# High-level modules should not depend on low-level modules.
# ===================================================================
dotnet_diagnostic.CA1050.severity = error        # Declare types in namespaces (MANDATORY)
dotnet_diagnostic.CA1062.severity = none         # Validate public arguments (we use ArgumentNullException.ThrowIfNull)
dotnet_diagnostic.CA1063.severity = error        # Implement IDisposable correctly
dotnet_diagnostic.CA1710.severity = warning      # Identifiers should have correct suffix
dotnet_diagnostic.CA1711.severity = warning      # Identifiers should not have incorrect suffix
dotnet_diagnostic.CA1712.severity = warning      # Do not prefix enum values with type name
dotnet_diagnostic.CA1713.severity = warning      # Events should not have before or after prefix
dotnet_diagnostic.CA1714.severity = warning      # Flags enums should have plural names
dotnet_diagnostic.CA1715.severity = error        # Identifiers should have correct prefix (T prefix mandatory)
dotnet_diagnostic.CA1716.severity = warning      # Identifiers should not match keywords
dotnet_diagnostic.CA1717.severity = warning      # Only FlagsAttribute enums should have plural names
dotnet_diagnostic.CA1720.severity = error        # Identifiers should not contain type names
dotnet_diagnostic.CA1721.severity = warning      # Property names should not match get methods
dotnet_diagnostic.CA1724.severity = warning      # Type names should not match namespaces
dotnet_diagnostic.CA1725.severity = warning      # Parameter names should match base declaration

# ===================================================================
# COMPOSITION OVER INHERITANCE - ENFORCEMENT
# Enforces sealed classes and interface-based design per standards.md.
# Inheritance should only be used for stable taxonomies.
# ===================================================================
# CA1052: Static holder types should be sealed (configured above)
# CA1852: Seal internal types (configured above)
# CA1501: Avoid excessive inheritance - max depth 5 (configured above)

# Additional composition enforcement
dotnet_diagnostic.CA1001.severity = error        # Types that own disposable fields should be disposable
dotnet_diagnostic.CA1002.severity = warning      # Do not expose generic lists
dotnet_diagnostic.CA1003.severity = warning      # Use generic event handler instances
dotnet_diagnostic.CA1005.severity = warning      # Avoid excessive parameters on generic types
dotnet_diagnostic.CA1019.severity = warning      # Define accessors for attribute arguments
dotnet_diagnostic.CA1021.severity = warning      # Avoid out parameters
dotnet_diagnostic.CA1030.severity = warning      # Use events where appropriate
dotnet_diagnostic.CA1032.severity = warning      # Implement standard exception constructors
dotnet_diagnostic.CA1036.severity = warning      # Override methods on comparable types
dotnet_diagnostic.CA1048.severity = warning      # Do not declare virtual members in sealed types
dotnet_diagnostic.CA1049.severity = warning      # Types that own native resources should be disposable
dotnet_diagnostic.CA1053.severity = error        # Static holder types should not have constructors
dotnet_diagnostic.CA1059.severity = warning      # Members should not expose certain concrete types

# ===================================================================
# FUNCTIONAL PROGRAMMING PATTERNS - ENFORCEMENT
# Enforces immutability, pure functions, and functional patterns
# as required by standards.md requirement 8.
# ===================================================================

# Immutability enforcement
dotnet_diagnostic.IDE0044.severity = error       # Add readonly modifier (configured above)
dotnet_diagnostic.CA1805.severity = warning      # Do not initialize unnecessarily
dotnet_diagnostic.CA1819.severity = warning      # Properties should not return arrays (prefer IReadOnlyList)
dotnet_diagnostic.CA2227.severity = warning      # Collection properties should be read only

# Record types and value equality
dotnet_diagnostic.IDE0050.severity = warning     # Convert anonymous type to tuple
dotnet_diagnostic.CA1067.severity = error        # Override Equals when implementing IEquatable
dotnet_diagnostic.CA1066.severity = warning      # Implement IEquatable when overriding Equals

# Pure function patterns
dotnet_diagnostic.CA1822.severity = warning      # Mark members as static (pure functions)
dotnet_diagnostic.CA1062.severity = none         # Validate arguments (allow for pure functions)

# Higher-order functions and LINQ
dotnet_diagnostic.CA1826.severity = error        # Use property instead of Linq Enumerable method
dotnet_diagnostic.CA1827.severity = error        # Do not use Count/LongCount when Any can be used
dotnet_diagnostic.CA1828.severity = error        # Do not use CountAsync/LongCountAsync when AnyAsync can be used
dotnet_diagnostic.CA1829.severity = error        # Use Length/Count property instead of Enumerable.Count
dotnet_diagnostic.CA1851.severity = error        # Possible multiple enumerations of IEnumerable collection
dotnet_diagnostic.CA1860.severity = error        # Avoid using Enumerable.Any() extension method

# Side effect detection and naming
# (No specific analyzer rules - enforced through code review and naming conventions)

# ===================================================================
# PERFORMANCE OPTIMIZATION RULES
# ===================================================================

# Memory and allocation optimization
dotnet_diagnostic.CA1822.severity = warning      # Mark members as static
dotnet_diagnostic.CA1825.severity = warning      # Avoid zero-length array allocations
dotnet_diagnostic.CA1826.severity = warning      # Use property instead of Linq Enumerable method
dotnet_diagnostic.CA1827.severity = warning      # Do not use Count/LongCount when Any can be used
dotnet_diagnostic.CA1828.severity = warning      # Do not use CountAsync/LongCountAsync when AnyAsync can be used
dotnet_diagnostic.CA1829.severity = warning      # Use Length/Count property instead of Enumerable.Count method
dotnet_diagnostic.CA1830.severity = warning      # Prefer strongly-typed Append and Insert method overloads on StringBuilder
dotnet_diagnostic.CA1831.severity = warning      # Use AsSpan instead of Range-based indexers for string when appropriate
dotnet_diagnostic.CA1832.severity = warning      # Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array
dotnet_diagnostic.CA1833.severity = warning      # Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array
dotnet_diagnostic.CA1834.severity = warning      # Use StringBuilder.Append(char) for single character strings
dotnet_diagnostic.CA1835.severity = warning      # Prefer the memory-based overloads of ReadAsync/WriteAsync methods in stream-based classes
dotnet_diagnostic.CA1836.severity = warning      # Prefer IsEmpty over Count when available
dotnet_diagnostic.CA1837.severity = warning      # Use Environment.ProcessId instead of Process.GetCurrentProcess().Id
dotnet_diagnostic.CA1838.severity = warning      # Avoid StringBuilder parameters for P/Invokes
dotnet_diagnostic.CA1839.severity = warning      # Use Environment.ProcessPath instead of Process.GetCurrentProcess().MainModule.FileName
dotnet_diagnostic.CA1840.severity = warning      # Use Environment.CurrentManagedThreadId instead of Thread.CurrentThread.ManagedThreadId
dotnet_diagnostic.CA1841.severity = warning      # Prefer Dictionary Contains methods
dotnet_diagnostic.CA1842.severity = warning      # Do not use WhenAll with a single task
dotnet_diagnostic.CA1843.severity = warning      # Do not use WhenAny with a single task
dotnet_diagnostic.CA1844.severity = warning      # Provide memory-based overrides of async methods when subclassing Stream
dotnet_diagnostic.CA1845.severity = warning      # Use span-based string.Concat
dotnet_diagnostic.CA1846.severity = warning      # Prefer AsSpan over Substring
dotnet_diagnostic.CA1847.severity = warning      # Use string.Contains(char) instead of string.Contains(string) with single characters
dotnet_diagnostic.CA1848.severity = warning      # Use the LoggerMessage delegates
dotnet_diagnostic.CA1849.severity = warning      # Call async methods when in an async method
dotnet_diagnostic.CA1850.severity = warning      # Prefer static HashData method over ComputeHash
dotnet_diagnostic.CA1851.severity = warning      # Possible multiple enumerations of IEnumerable collection
dotnet_diagnostic.CA1853.severity = warning      # Unnecessary call to Dictionary.ContainsKey(key)
dotnet_diagnostic.CA1854.severity = warning      # Prefer the IDictionary.TryGetValue(TKey, out TValue) method
dotnet_diagnostic.CA1855.severity = warning      # Use Span<T>.Clear() instead of Span<T>.Fill()
dotnet_diagnostic.CA1856.severity = warning      # Incorrect usage of ConstantExpected attribute
dotnet_diagnostic.CA1857.severity = warning      # Use ConstantExpected attribute for parameters
dotnet_diagnostic.CA1858.severity = warning      # Use StartsWith instead of IndexOf
dotnet_diagnostic.CA1859.severity = warning      # Use concrete types when possible for improved performance
dotnet_diagnostic.CA1860.severity = warning      # Avoid using Enumerable.Any() extension method
dotnet_diagnostic.CA1861.severity = warning      # Avoid constant arrays as arguments
dotnet_diagnostic.CA1862.severity = warning      # Use the StringComparison method overloads to perform case-insensitive string comparisons
dotnet_diagnostic.CA1863.severity = warning      # Use composite format
dotnet_diagnostic.CA1864.severity = warning      # Prefer the IDictionary.TryAdd(TKey, TValue) method
dotnet_diagnostic.CA1865.severity = warning      # Use char overload
dotnet_diagnostic.CA1866.severity = warning      # Use char overload
dotnet_diagnostic.CA1867.severity = warning      # Use char overload
dotnet_diagnostic.CA1868.severity = warning      # Unnecessary call to Contains for sets
dotnet_diagnostic.CA1869.severity = warning      # Cache and reuse JsonSerializerOptions instances
dotnet_diagnostic.CA1870.severity = warning      # Use a cached SearchValues instance

# ===================================================================
# SECURITY RULES
# ===================================================================

# Resource management and disposal
dotnet_diagnostic.CA2000.severity = warning      # Dispose objects before losing scope
dotnet_diagnostic.CA2002.severity = warning      # Do not lock on objects with weak identity
dotnet_diagnostic.CA2008.severity = warning      # Do not create tasks without passing a TaskScheduler
dotnet_diagnostic.CA2009.severity = warning      # Do not call ToImmutableCollection on an ImmutableCollection value
dotnet_diagnostic.CA2011.severity = warning      # Do not assign property within its setter
dotnet_diagnostic.CA2012.severity = warning      # Use ValueTasks correctly
dotnet_diagnostic.CA2013.severity = warning      # Do not use ReferenceEquals with value types
dotnet_diagnostic.CA2014.severity = warning      # Do not use stackalloc in loops
dotnet_diagnostic.CA2015.severity = warning      # Do not define finalizers for types derived from MemoryManager<T>
dotnet_diagnostic.CA2016.severity = warning      # Forward the CancellationToken parameter to methods
dotnet_diagnostic.CA2017.severity = warning      # Parameter count mismatch
dotnet_diagnostic.CA2018.severity = warning      # Buffer.BlockCopy argument validation
dotnet_diagnostic.CA2019.severity = warning      # ThreadStatic fields should not use inline initialization
dotnet_diagnostic.CA2020.severity = warning      # Prevent from behavioral change

# Cryptography and security
dotnet_diagnostic.CA5350.severity = error        # Do Not Use Weak Cryptographic Algorithms
dotnet_diagnostic.CA5351.severity = error        # Do Not Use Broken Cryptographic Algorithms
dotnet_diagnostic.CA5385.severity = error        # Use Rivest–Shamir–Adleman (RSA) algorithm with sufficient key size
dotnet_diagnostic.CA5397.severity = error        # Do not use deprecated SslProtocols values

# Injection vulnerabilities
dotnet_diagnostic.CA3001.severity = warning      # Review code for SQL injection vulnerabilities
dotnet_diagnostic.CA3002.severity = warning      # Review code for XSS vulnerabilities
dotnet_diagnostic.CA3003.severity = warning      # Review code for file path injection vulnerabilities
dotnet_diagnostic.CA3004.severity = warning      # Review code for information disclosure vulnerabilities
dotnet_diagnostic.CA3005.severity = warning      # Review code for LDAP injection vulnerabilities
dotnet_diagnostic.CA3006.severity = warning      # Review code for process command injection vulnerabilities
dotnet_diagnostic.CA3007.severity = warning      # Review code for open redirect vulnerabilities
dotnet_diagnostic.CA3008.severity = warning      # Review code for XPath injection vulnerabilities
dotnet_diagnostic.CA3009.severity = warning      # Review code for XML injection vulnerabilities
dotnet_diagnostic.CA3010.severity = warning      # Review code for XAML injection vulnerabilities
dotnet_diagnostic.CA3011.severity = warning      # Review code for DLL injection vulnerabilities
dotnet_diagnostic.CA3012.severity = warning      # Review code for regex injection vulnerabilities

# ===================================================================
# CODE QUALITY & MAINTAINABILITY
# ===================================================================

dotnet_diagnostic.CA1031.severity = none         # Catch general exceptions - intentional for error handling pattern
dotnet_diagnostic.CA2007.severity = none         # ConfigureAwait - not needed for library code

# Formatting
csharp_new_line_before_open_brace = all
csharp_new_line_before_else = true
csharp_new_line_before_catch = true
csharp_new_line_before_finally = true
csharp_space_after_cast = false
csharp_space_after_keywords_in_control_flow_statements = true
csharp_preserve_single_line_blocks = true
csharp_preserve_single_line_statements = false

# Modern C# features - enforce C# 12 / .NET 8 best practices
csharp_prefer_simple_using_statement = true:warning
csharp_style_namespace_declarations = file_scoped:warning                  # Enforce file-scoped namespaces to reduce indentation
csharp_style_prefer_method_group_conversion = true:warning
csharp_style_prefer_top_level_statements = false:suggestion
csharp_style_expression_bodied_methods = false:none
csharp_style_expression_bodied_constructors = false:none
csharp_style_expression_bodied_operators = false:none
csharp_style_expression_bodied_properties = true:warning
csharp_style_expression_bodied_indexers = true:warning
csharp_style_expression_bodied_accessors = true:warning

# Naming conventions
dotnet_naming_rule.interface_should_be_begins_with_i.severity = warning
dotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface
dotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i

dotnet_naming_rule.types_should_be_pascal_case.severity = warning
dotnet_naming_rule.types_should_be_pascal_case.symbols = types
dotnet_naming_rule.types_should_be_pascal_case.style = pascal_case

dotnet_naming_rule.non_field_members_should_be_pascal_case.severity = warning
dotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members
dotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case

# Symbol specifications
dotnet_naming_symbols.interface.applicable_kinds = interface
dotnet_naming_symbols.interface.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.interface.required_modifiers = 

dotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum
dotnet_naming_symbols.types.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.types.required_modifiers = 

dotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method
dotnet_naming_symbols.non_field_members.applicable_accessibilities = public, internal, private, protected, protected_internal, private_protected
dotnet_naming_symbols.non_field_members.required_modifiers = 

# Naming styles
dotnet_naming_style.pascal_case.required_prefix = 
dotnet_naming_style.pascal_case.required_suffix = 
dotnet_naming_style.pascal_case.word_separator = 
dotnet_naming_style.pascal_case.capitalization = pascal_case

dotnet_naming_style.begins_with_i.required_prefix = I
dotnet_naming_style.begins_with_i.required_suffix = 
dotnet_naming_style.begins_with_i.word_separator = 
dotnet_naming_style.begins_with_i.capitalization = pascal_case

# ===================================================================
# MEZIANTOU.ANALYZER - COMPREHENSIVE CONFIGURATION
# Performance, Async Patterns, Span/Memory Optimization, String Operations
# ===================================================================
#
# Meziantou.Analyzer provides 200+ rules for enforcing best practices
# in C# code. This configuration aligns with standards.md requirements:
#
# - PERFORMANCE: Zero-tolerance for allocation-heavy patterns
# - ASYNC PATTERNS: ConfigureAwait, CancellationToken propagation
# - SPAN/MEMORY: ReadOnlySpan<char>, Memory<T> optimization
# - STRING OPERATIONS: StringBuilder, string.Create, culture-aware
# - NAMING: Consistent conventions and suffix requirements
#
# All performance-critical rules are set to ERROR severity.
# Async pattern violations are ERROR to prevent deadlocks.
# Optimization suggestions are WARNING to encourage best practices.
#
# ===================================================================

# ===================================================================
# CRITICAL PERFORMANCE RULES - ERROR SEVERITY
# These rules detect allocation-heavy patterns that must be eliminated.
# ===================================================================

# String comparison and culture-awareness (CRITICAL)
dotnet_diagnostic.MA0001.severity = error        # StringComparison is missing
dotnet_diagnostic.MA0002.severity = error        # IEqualityComparer or IComparer is missing
dotnet_diagnostic.MA0006.severity = error        # Use String.Equals instead of equality operator
dotnet_diagnostic.MA0011.severity = error        # IFormatProvider is missing
dotnet_diagnostic.MA0021.severity = error        # Use StringComparer.GetHashCode instead of string.GetHashCode
dotnet_diagnostic.MA0024.severity = error        # Use an explicit StringComparer when possible
dotnet_diagnostic.MA0074.severity = error        # Avoid implicit culture-sensitive methods
dotnet_diagnostic.MA0075.severity = warning      # Do not use implicit culture-sensitive ToString
dotnet_diagnostic.MA0076.severity = warning      # Do not use implicit culture-sensitive ToString in interpolated strings

# StringBuilder optimization (CRITICAL)
dotnet_diagnostic.MA0028.severity = error        # Optimize StringBuilder usage
dotnet_diagnostic.CA1830.severity = error        # Prefer strongly-typed Append and Insert method overloads on StringBuilder
dotnet_diagnostic.CA1834.severity = error        # Use StringBuilder.Append(char) for single character strings

# String operations optimization (CRITICAL)
dotnet_diagnostic.MA0089.severity = error        # Optimize string method usage
dotnet_diagnostic.CA1845.severity = error        # Use span-based string.Concat
dotnet_diagnostic.CA1846.severity = error        # Prefer AsSpan over Substring
dotnet_diagnostic.CA1847.severity = error        # Use string.Contains(char) instead of string.Contains(string) with single characters
dotnet_diagnostic.CA1858.severity = error        # Use StartsWith instead of IndexOf
dotnet_diagnostic.CA1862.severity = error        # Use the StringComparison method overloads to perform case-insensitive string comparisons
dotnet_diagnostic.CA1865.severity = error        # Use char overload
dotnet_diagnostic.CA1866.severity = error        # Use char overload
dotnet_diagnostic.CA1867.severity = error        # Use char overload

# ===================================================================
# ASYNC PATTERNS - ERROR SEVERITY
# Enforces proper async/await patterns to prevent deadlocks and ensure
# correct asynchronous behavior per standards.md requirements.
# ===================================================================

# ConfigureAwait enforcement (MANDATORY for library code)
dotnet_diagnostic.MA0004.severity = error        # Use Task.ConfigureAwait (CRITICAL)
dotnet_diagnostic.CA2007.severity = none         # ConfigureAwait - handled by MA0004

# Async method patterns (CRITICAL)
dotnet_diagnostic.MA0022.severity = error        # Return Task.FromResult instead of returning null
dotnet_diagnostic.MA0042.severity = error        # Do not use blocking calls in an async method
dotnet_diagnostic.MA0045.severity = warning      # Do not use blocking calls in a sync method (need to make calling method async)
dotnet_diagnostic.MA0100.severity = error        # Await task before disposing of resources
dotnet_diagnostic.MA0129.severity = error        # Await task in using statement
dotnet_diagnostic.MA0134.severity = error        # Observe result of async calls
dotnet_diagnostic.MA0147.severity = error        # Avoid async void method for delegate
dotnet_diagnostic.MA0155.severity = error        # Do not use async void methods
dotnet_diagnostic.CA1849.severity = error        # Call async methods when in an async method

# CancellationToken propagation (REQUIRED)
dotnet_diagnostic.MA0032.severity = warning      # Use an overload with a CancellationToken argument
dotnet_diagnostic.MA0040.severity = error        # Forward the CancellationToken parameter to methods that take one
dotnet_diagnostic.MA0079.severity = error        # Forward the CancellationToken using .WithCancellation()
dotnet_diagnostic.MA0080.severity = warning      # Use a cancellation token using .WithCancellation()
dotnet_diagnostic.CA2016.severity = error        # Forward the CancellationToken parameter to methods
dotnet_diagnostic.CA1068.severity = error        # CancellationToken parameters must come last

# Async naming conventions (REQUIRED)
dotnet_diagnostic.MA0137.severity = warning      # Use 'Async' suffix when a method returns an awaitable type
dotnet_diagnostic.MA0138.severity = warning      # Do not use 'Async' suffix when a method does not return an awaitable type
dotnet_diagnostic.MA0156.severity = warning      # Use 'Async' suffix when a method returns IAsyncEnumerable
dotnet_diagnostic.MA0157.severity = warning      # Do not use 'Async' suffix when a method returns IAsyncEnumerable

# Async optimization
dotnet_diagnostic.MA0152.severity = warning      # Use Unwrap instead of using await twice
dotnet_diagnostic.CA1842.severity = error        # Do not use WhenAll with a single task
dotnet_diagnostic.CA1843.severity = error        # Do not use WhenAny with a single task
dotnet_diagnostic.CA1844.severity = warning      # Provide memory-based overrides of async methods when subclassing Stream

# ===================================================================
# SPAN/MEMORY OPTIMIZATION - WARNING SEVERITY
# Enforces use of Span<T>, Memory<T>, and ReadOnlySpan<char> for
# high-performance, allocation-free operations per standards.md.
# ===================================================================

# Span/Memory API usage (RECOMMENDED)
dotnet_diagnostic.MA0109.severity = suggestion   # Consider adding an overload with a Span or Memory
dotnet_diagnostic.CA1831.severity = error        # Use AsSpan instead of Range-based indexers for string when appropriate
dotnet_diagnostic.CA1832.severity = error        # Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array
dotnet_diagnostic.CA1833.severity = error        # Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array
dotnet_diagnostic.CA1835.severity = error        # Prefer the memory-based overloads of ReadAsync/WriteAsync methods in stream-based classes
dotnet_diagnostic.CA1855.severity = warning      # Use Span<T>.Clear() instead of Span<T>.Fill()

# Array and collection optimization
dotnet_diagnostic.MA0005.severity = error        # Use Array.Empty()
dotnet_diagnostic.CA1825.severity = error        # Avoid zero-length array allocations
dotnet_diagnostic.CA1861.severity = error        # Avoid constant arrays as arguments
dotnet_diagnostic.CA2014.severity = error        # Do not use stackalloc in loops

# Struct layout and performance
dotnet_diagnostic.MA0008.severity = warning      # Add StructLayoutAttribute
dotnet_diagnostic.MA0102.severity = warning      # Make member readonly
dotnet_diagnostic.MA0168.severity = suggestion   # Use readonly struct for in or ref readonly parameter
dotnet_diagnostic.CA2013.severity = error        # Do not use ReferenceEquals with value types

# Value type equality and hashing
dotnet_diagnostic.MA0065.severity = warning      # Default ValueType.Equals or HashCode is used for struct equality
dotnet_diagnostic.MA0066.severity = warning      # Hash table unfriendly type is used in a hash table
dotnet_diagnostic.MA0077.severity = error        # A class that provides Equals(T) should implement IEquatable
dotnet_diagnostic.CA1066.severity = error        # Implement IEquatable when overriding Equals
dotnet_diagnostic.CA1067.severity = error        # Override Equals when implementing IEquatable

# ===================================================================
# LINQ AND COLLECTION PERFORMANCE - ERROR/WARNING SEVERITY
# Optimizes LINQ usage and prevents multiple enumeration issues.
# ===================================================================

# LINQ optimization (CRITICAL)
dotnet_diagnostic.MA0020.severity = warning      # Use direct methods instead of LINQ methods
dotnet_diagnostic.MA0029.severity = warning      # Combine LINQ methods
dotnet_diagnostic.MA0030.severity = warning      # Remove useless OrderBy call
dotnet_diagnostic.MA0031.severity = warning      # Optimize Enumerable.Count() usage
dotnet_diagnostic.MA0063.severity = warning      # Use Where before OrderBy
dotnet_diagnostic.MA0078.severity = warning      # Use 'Cast' instead of 'Select' to cast
dotnet_diagnostic.MA0098.severity = warning      # Use indexer instead of LINQ methods
dotnet_diagnostic.MA0112.severity = suggestion   # Use 'Count > 0' instead of 'Any()'
dotnet_diagnostic.MA0159.severity = warning      # Use 'Order' instead of 'OrderBy'

# Multiple enumeration prevention (CRITICAL)
dotnet_diagnostic.CA1851.severity = error        # Possible multiple enumerations of IEnumerable collection
dotnet_diagnostic.CA1860.severity = error        # Avoid using Enumerable.Any() extension method

# Collection method optimization (CRITICAL)
dotnet_diagnostic.CA1826.severity = error        # Use property instead of Linq Enumerable method
dotnet_diagnostic.CA1827.severity = error        # Do not use Count/LongCount when Any can be used
dotnet_diagnostic.CA1828.severity = error        # Do not use CountAsync/LongCountAsync when AnyAsync can be used
dotnet_diagnostic.CA1829.severity = error        # Use Length/Count property instead of Enumerable.Count
dotnet_diagnostic.CA1836.severity = error        # Prefer IsEmpty over Count when available
dotnet_diagnostic.CA1841.severity = error        # Prefer Dictionary Contains methods
dotnet_diagnostic.CA1853.severity = error        # Unnecessary call to Dictionary.ContainsKey(key)
dotnet_diagnostic.CA1854.severity = error        # Prefer the IDictionary.TryGetValue(TKey, out TValue) method
dotnet_diagnostic.CA1864.severity = error        # Prefer the IDictionary.TryAdd(TKey, TValue) method
dotnet_diagnostic.CA1868.severity = error        # Unnecessary call to Contains for sets
dotnet_diagnostic.MA0160.severity = warning      # Use ContainsKey instead of TryGetValue

# Collection usage patterns
dotnet_diagnostic.MA0103.severity = error        # Use SequenceEqual instead of equality operator
dotnet_diagnostic.MA0128.severity = warning      # Use 'is' operator instead of SequenceEqual

# ===================================================================
# DESIGN AND ARCHITECTURE - WARNING/ERROR SEVERITY
# Enforces SOLID principles, composition over inheritance, and
# interface-first design per standards.md requirements.
# ===================================================================

# Class design (SOLID principles)
dotnet_diagnostic.MA0017.severity = error        # Abstract types should not have public or internal constructors
dotnet_diagnostic.MA0036.severity = warning      # Make class static
dotnet_diagnostic.MA0053.severity = warning      # Make class sealed (composition over inheritance)
dotnet_diagnostic.MA0056.severity = error        # Do not call overridable members in constructor

# Method length and complexity (LOC enforcement)
dotnet_diagnostic.MA0051.severity = error        # Method is too long (aligns with 300 LOC limit)

# Exception handling patterns
dotnet_diagnostic.MA0012.severity = error        # Do not raise reserved exception type
dotnet_diagnostic.MA0013.severity = error        # Types should not extend System.ApplicationException
dotnet_diagnostic.MA0014.severity = error        # Do not raise System.ApplicationException type
dotnet_diagnostic.MA0015.severity = error        # Specify the parameter name in ArgumentException
dotnet_diagnostic.MA0025.severity = error        # Implement the functionality instead of throwing NotImplementedException
dotnet_diagnostic.MA0027.severity = error        # Prefer rethrowing an exception implicitly
dotnet_diagnostic.MA0043.severity = warning      # Use nameof operator in ArgumentException
dotnet_diagnostic.MA0054.severity = error        # Embed the caught exception as innerException
dotnet_diagnostic.MA0072.severity = error        # Do not throw from a finally block
dotnet_diagnostic.MA0086.severity = error        # Do not throw from a finalizer

# Interface and abstraction design
dotnet_diagnostic.MA0016.severity = warning      # Prefer using collection abstraction instead of implementation
dotnet_diagnostic.MA0094.severity = error        # A class that provides CompareTo(T) should implement IComparable
dotnet_diagnostic.MA0095.severity = error        # A class that implements IEquatable should override Equals(object)
dotnet_diagnostic.MA0096.severity = error        # A class that implements IComparable should also implement IEquatable
dotnet_diagnostic.MA0097.severity = error        # A class that implements IComparable or IComparable should override comparison operators

# Finalizer and disposal patterns
dotnet_diagnostic.MA0055.severity = error        # Do not use finalizer
dotnet_diagnostic.CA2015.severity = error        # Do not define finalizers for types derived from MemoryManager<T>

# ===================================================================
# NAMING CONVENTIONS - WARNING SEVERITY
# Enforces consistent naming patterns for attributes, exceptions,
# event args, and other special types.
# ===================================================================

dotnet_diagnostic.MA0057.severity = warning      # Class name should end with 'Attribute'
dotnet_diagnostic.MA0058.severity = warning      # Class name should end with 'Exception'
dotnet_diagnostic.MA0059.severity = warning      # Class name should end with 'EventArgs'
dotnet_diagnostic.MA0048.severity = error        # File name must match type name
dotnet_diagnostic.MA0047.severity = error        # Declare types in namespaces
dotnet_diagnostic.MA0049.severity = error        # Type name should not match containing namespace
dotnet_diagnostic.MA0104.severity = warning      # Do not create a type with a name from the BCL

# ===================================================================
# USAGE AND CORRECTNESS - ERROR/WARNING SEVERITY
# Prevents common mistakes and enforces correct API usage.
# ===================================================================

# Event patterns
dotnet_diagnostic.MA0019.severity = error        # Use EventArgs.Empty
dotnet_diagnostic.MA0046.severity = error        # Use EventHandler to declare events
dotnet_diagnostic.MA0091.severity = error        # Sender should be 'this' for instance events
dotnet_diagnostic.MA0092.severity = error        # Sender should be 'null' for static events
dotnet_diagnostic.MA0093.severity = error        # EventArgs should not be null
dotnet_diagnostic.MA0085.severity = error        # Anonymous delegates should not be used to unsubscribe from Events

# Enum patterns
dotnet_diagnostic.MA0062.severity = error        # Non-flags enums should not be marked with "FlagsAttribute"
dotnet_diagnostic.MA0052.severity = warning      # Replace constant Enum.ToString with nameof
dotnet_diagnostic.MA0099.severity = error        # Use Explicit enum value instead of 0

# Guid and DateTime usage
dotnet_diagnostic.MA0067.severity = warning      # Use Guid.Empty
dotnet_diagnostic.MA0113.severity = warning      # Use DateTime.UnixEpoch
dotnet_diagnostic.MA0114.severity = warning      # Use DateTimeOffset.UnixEpoch
dotnet_diagnostic.MA0132.severity = error        # Do not convert implicitly to DateTimeOffset
dotnet_diagnostic.MA0133.severity = warning      # Use DateTimeOffset instead of relying on the implicit conversion
dotnet_diagnostic.MA0176.severity = warning      # Optimize guid creation

# Type checking and casting
dotnet_diagnostic.MA0130.severity = error        # GetType() should not be used on System.Type instances
dotnet_diagnostic.MA0131.severity = error        # ArgumentNullException.ThrowIfNull should not be used with non-nullable types
dotnet_diagnostic.MA0169.severity = error        # Use Equals method instead of operator

# ===================================================================
# CODE QUALITY AND STYLE - WARNING/SUGGESTION SEVERITY
# Improves code readability and maintainability.
# ===================================================================

# Code simplification
dotnet_diagnostic.MA0003.severity = suggestion   # Add parameter name to improve readability
dotnet_diagnostic.MA0007.severity = suggestion   # Add a comma after the last value
dotnet_diagnostic.MA0037.severity = error        # Remove empty statement
dotnet_diagnostic.MA0044.severity = warning      # Remove useless ToString call
dotnet_diagnostic.MA0071.severity = suggestion   # Avoid using redundant else
dotnet_diagnostic.MA0073.severity = suggestion   # Avoid comparison with bool constant
dotnet_diagnostic.MA0090.severity = suggestion   # Remove empty else/finally block
dotnet_diagnostic.MA0108.severity = suggestion   # Remove redundant argument value
dotnet_diagnostic.MA0140.severity = error        # Both if and else branch have identical code
dotnet_diagnostic.MA0150.severity = error        # Do not call the default object.ToString explicitly

# Pattern matching preferences
dotnet_diagnostic.MA0141.severity = suggestion   # Use pattern matching instead of inequality operators for null check
dotnet_diagnostic.MA0142.severity = suggestion   # Use pattern matching instead of equality operators for null check
dotnet_diagnostic.MA0148.severity = suggestion   # Use pattern matching instead of equality operators for discrete value
dotnet_diagnostic.MA0149.severity = suggestion   # Use pattern matching instead of inequality operators for discrete value
dotnet_diagnostic.MA0171.severity = suggestion   # Use pattern matching instead of HasValue for Nullable check
dotnet_diagnostic.MA0164.severity = warning      # Use parentheses to make not pattern clearer

# String and interpolation
dotnet_diagnostic.MA0101.severity = warning      # String contains an implicit end of line character
dotnet_diagnostic.MA0136.severity = warning      # Raw String contains an implicit end of line character
dotnet_diagnostic.MA0165.severity = suggestion   # Make interpolated string
dotnet_diagnostic.MA0127.severity = suggestion   # Use String.Equals instead of is pattern

# Method and property design
dotnet_diagnostic.MA0050.severity = warning      # Validate arguments correctly in iterator methods
dotnet_diagnostic.MA0060.severity = error        # The value returned by Stream.Read/Stream.ReadAsync is not used
dotnet_diagnostic.MA0061.severity = error        # Method overrides should not change default values
dotnet_diagnostic.MA0081.severity = error        # Method overrides should not omit params keyword
dotnet_diagnostic.MA0121.severity = suggestion   # Do not overwrite parameter value
dotnet_diagnostic.MA0143.severity = error        # Primary constructor parameters should be readonly

# ===================================================================
# SECURITY AND THREADING - ERROR SEVERITY
# Prevents security vulnerabilities and threading issues.
# ===================================================================

# Security patterns
dotnet_diagnostic.MA0009.severity = error        # Add regex evaluation timeout
dotnet_diagnostic.MA0023.severity = warning      # Add RegexOptions.ExplicitCapture
dotnet_diagnostic.MA0039.severity = error        # Do not write your own certificate validation method
dotnet_diagnostic.MA0110.severity = warning      # Use the Regex source generator

# Threading and synchronization
dotnet_diagnostic.MA0033.severity = error        # Do not tag instance fields with ThreadStaticAttribute
dotnet_diagnostic.MA0035.severity = error        # Do not use dangerous threading methods
dotnet_diagnostic.MA0064.severity = error        # Avoid locking on publicly accessible instance
dotnet_diagnostic.MA0158.severity = warning      # Use System.Threading.Lock
dotnet_diagnostic.MA0173.severity = warning      # Use LazyInitializer.EnsureInitialize
dotnet_diagnostic.CA2019.severity = error        # ThreadStatic fields should not use inline initialization

# Logical correctness
dotnet_diagnostic.MA0082.severity = error        # NaN should not be used in comparisons
dotnet_diagnostic.MA0172.severity = error        # Both sides of the logical operation are identical

# ===================================================================
# PERFORMANCE OPTIMIZATION - WARNING SEVERITY
# Additional performance improvements and best practices.
# ===================================================================

# Closure and lambda optimization
dotnet_diagnostic.MA0105.severity = warning      # Use the lambda parameters instead of using a closure
dotnet_diagnostic.MA0106.severity = warning      # Avoid closure by using an overload with the 'factoryArgument' parameter

# Modern API usage
dotnet_diagnostic.MA0111.severity = warning      # Use string.Create instead of FormattableString
dotnet_diagnostic.MA0144.severity = warning      # Use System.OperatingSystem to check the current OS
dotnet_diagnostic.CA1837.severity = warning      # Use Environment.ProcessId instead of Process.GetCurrentProcess().Id
dotnet_diagnostic.CA1839.severity = warning      # Use Environment.ProcessPath instead of Process.GetCurrentProcess().MainModule.FileName
dotnet_diagnostic.CA1840.severity = warning      # Use Environment.CurrentManagedThreadId instead of Thread.CurrentThread.ManagedThreadId
dotnet_diagnostic.CA1850.severity = warning      # Prefer static HashData method over ComputeHash
dotnet_diagnostic.CA1869.severity = warning      # Cache and reuse JsonSerializerOptions instances
dotnet_diagnostic.CA1870.severity = warning      # Use a cached SearchValues instance

# TimeProvider support (modern .NET)
dotnet_diagnostic.MA0166.severity = warning      # Forward the TimeProvider to methods that take one
dotnet_diagnostic.MA0167.severity = suggestion   # Use an overload with a TimeProvider argument

# ===================================================================
# ATTRIBUTES AND METADATA - WARNING SEVERITY
# Ensures correct usage of attributes and metadata.
# ===================================================================

dotnet_diagnostic.MA0010.severity = error        # Mark attributes with AttributeUsageAttribute
dotnet_diagnostic.MA0068.severity = error        # Invalid parameter name for nullable attribute
dotnet_diagnostic.MA0070.severity = warning      # Obsolete attributes should include explanations
dotnet_diagnostic.MA0083.severity = error        # ConstructorArgument parameters should exist in constructors
dotnet_diagnostic.MA0087.severity = error        # Parameters with [DefaultParameterValue] attributes should also be marked [Optional]
dotnet_diagnostic.MA0088.severity = error        # Use [DefaultParameterValue] instead of [DefaultValue]
dotnet_diagnostic.MA0151.severity = error        # DebuggerDisplay must contain valid members
dotnet_diagnostic.MA0154.severity = suggestion   # Use langword in XML comment
dotnet_diagnostic.MA0170.severity = error        # Type cannot be used as an attribute argument

# ===================================================================
# FRAMEWORK-SPECIFIC RULES - WARNING SEVERITY
# Blazor, logging, and other framework-specific patterns.
# ===================================================================

# Blazor component rules (if applicable)
dotnet_diagnostic.MA0115.severity = warning      # Unknown component parameter
dotnet_diagnostic.MA0116.severity = error        # Parameters with [SupplyParameterFromQuery] attributes should also be marked as [Parameter]
dotnet_diagnostic.MA0117.severity = error        # Parameters with [EditorRequired] attributes should also be marked as [Parameter]
dotnet_diagnostic.MA0118.severity = error        # [JSInvokable] methods must be public
dotnet_diagnostic.MA0119.severity = error        # JSRuntime must not be used in OnInitialized or OnInitializedAsync
dotnet_diagnostic.MA0120.severity = warning      # Use InvokeVoidAsync when the returned value is not used
dotnet_diagnostic.MA0122.severity = warning      # Parameters with [SupplyParameterFromQuery] attributes are only valid in routable components (@page)

# Logging rules
dotnet_diagnostic.MA0123.severity = error        # Sequence number must be a constant
dotnet_diagnostic.MA0124.severity = error        # Log parameter type is not valid
dotnet_diagnostic.MA0125.severity = error        # The list of log parameter types contains an invalid type
dotnet_diagnostic.MA0126.severity = error        # The list of log parameter types contains a duplicate
dotnet_diagnostic.MA0135.severity = error        # The log parameter has no configured type
dotnet_diagnostic.MA0139.severity = error        # Log parameter type is not valid
dotnet_diagnostic.MA0146.severity = error        # Name must be set explicitly on local functions
dotnet_diagnostic.MA0153.severity = error        # Do not log symbols decorated with DataClassificationAttribute directly
dotnet_diagnostic.CA1848.severity = warning      # Use the LoggerMessage delegates

# UnsafeAccessor attribute
dotnet_diagnostic.MA0145.severity = error        # Signature for [UnsafeAccessorAttribute] method is not valid

# ===================================================================
# PROCESS AND SYSTEM INTERACTION - WARNING SEVERITY
# Ensures safe process execution and system interaction.
# ===================================================================

dotnet_diagnostic.MA0161.severity = suggestion   # UseShellExecute must be explicitly set
dotnet_diagnostic.MA0162.severity = suggestion   # Use Process.Start overload with ProcessStartInfo
dotnet_diagnostic.MA0163.severity = error        # UseShellExecute must be false when redirecting standard input or output

# ===================================================================
# STYLE PREFERENCES - SUGGESTION SEVERITY
# Code style preferences that improve consistency.
# ===================================================================

dotnet_diagnostic.MA0174.severity = suggestion   # Record should use explicit 'class' keyword
dotnet_diagnostic.MA0175.severity = suggestion   # Record should not use explicit 'class' keyword

# ===================================================================
# DISABLED OR OPTIONAL RULES
# Rules that are disabled by default or not applicable to this project.
# ===================================================================

# Disabled by default (can be enabled if needed)
dotnet_diagnostic.MA0018.severity = none         # Do not declare static members on generic types (deprecated; use CA1000)
dotnet_diagnostic.MA0038.severity = none         # Make method static (deprecated, use CA1822)
dotnet_diagnostic.MA0041.severity = none         # Make property static (deprecated, use CA1822)
dotnet_diagnostic.MA0107.severity = none         # Do not use object.ToString (too restrictive)
dotnet_diagnostic.MA0109.severity = none         # Consider adding an overload with a Span or Memory (suggestion only)
dotnet_diagnostic.MA0112.severity = none         # Use 'Count > 0' instead of 'Any()' (context-dependent)

# ===================================================================
# MEZIANTOU.ANALYZER CONFIGURATION SUMMARY
# ===================================================================
#
# CONFIGURED RULES: 150+ rules explicitly configured
#
# ERROR SEVERITY (Build-breaking):
# - String comparison and culture-awareness (MA0001, MA0002, MA0006, MA0011, MA0021, MA0024, MA0074)
# - StringBuilder optimization (MA0028, CA1830, CA1834)
# - String operations (MA0089, CA1845, CA1846, CA1847, CA1858, CA1862, CA1865-CA1867)
# - Async patterns (MA0004, MA0022, MA0042, MA0100, MA0129, MA0134, MA0147, MA0155, CA1849)
# - CancellationToken propagation (MA0040, MA0079, CA2016, CA1068)
# - Span/Memory optimization (CA1831-CA1833, CA1835)
# - LINQ performance (CA1851, CA1860, CA1826-CA1829, CA1836, CA1841, CA1853-CA1854, CA1864, CA1868)
# - Design patterns (MA0017, MA0051, MA0012-MA0015, MA0025, MA0027, MA0043, MA0054, MA0072, MA0086)
# - Security (MA0009, MA0039, MA0033, MA0035, MA0064, MA0082, MA0172, CA2019)
#
# WARNING SEVERITY (Should fix before commit):
# - Performance optimizations (MA0020, MA0029-MA0031, MA0063, MA0078, MA0098, MA0159-MA0160)
# - Design improvements (MA0036, MA0053, MA0056, MA0016, MA0094-MA0097)
# - Code quality (MA0044, MA0050, MA0060-MA0061, MA0081, MA0143)
# - Modern API usage (MA0111, MA0144, CA1837, CA1839-CA1840, CA1850, CA1869-CA1870)
#
# SUGGESTION SEVERITY (Optional improvements):
# - Code style (MA0003, MA0007, MA0071, MA0073, MA0090, MA0108)
# - Pattern matching (MA0141-MA0142, MA0148-MA0149, MA0171)
# - Closures and lambdas (MA0105-MA0106)
#
# This configuration enforces zero-tolerance for performance issues,
# proper async patterns, and modern C# best practices as required by
# standards.md and the advanced analyzer enforcement specification.
#
# ===================================================================

# ===================================================================
# SONARANALYZER.CSHARP - COMPREHENSIVE CONFIGURATION
# Cognitive Complexity, Code Smells, Security, Maintainability
# ===================================================================
#
# SonarAnalyzer.CSharp provides comprehensive static analysis for C#
# focusing on cognitive complexity, code smells, security vulnerabilities,
# and maintainability issues. This configuration aligns with standards.md:
#
# - COGNITIVE COMPLEXITY: Maximum 15 per method (stricter than cyclomatic)
# - CODE SMELLS: God classes, duplicate code, dead code detection
# - SECURITY: Hardcoded credentials, weak crypto, injection vulnerabilities
# - MAINTAINABILITY: Method length (60 lines), class complexity (15 members)
# - EXCEPTION HANDLING: Empty catch blocks, generic exception catching
# - NESTING DEPTH: Maximum 3 levels to prevent deeply nested logic
#
# All security rules are set to ERROR severity (build-breaking).
# Code smell rules are ERROR to enforce quality standards.
# Maintainability rules are WARNING to encourage best practices.
#
# ===================================================================

# ===================================================================
# COGNITIVE COMPLEXITY - ERROR SEVERITY
# Cognitive complexity measures how difficult code is to understand,
# considering nesting, control flow, and logical operations.
# Stricter than cyclomatic complexity for maintainability.
# ===================================================================

# Cognitive complexity threshold (CRITICAL - aligns with standards.md)
dotnet_diagnostic.S3776.severity = error         # Cognitive Complexity of methods should not be too high
dotnet_code_quality.S3776.threshold = 15         # Maximum cognitive complexity per method

# Related complexity rules
dotnet_diagnostic.S1541.severity = warning       # Cyclomatic complexity should not be too high
dotnet_code_quality.S1541.threshold = 10         # Maximum cyclomatic complexity

# ===================================================================
# METHOD AND CLASS SIZE LIMITS - ERROR SEVERITY
# Enforces minimal LOC requirements per standards.md (300 lines max).
# Method length and class complexity limits prevent bloated code.
# ===================================================================

# Method length (CRITICAL - 60 lines max per method)
dotnet_diagnostic.S138.severity = error          # Functions should not have too many lines of code
dotnet_code_quality.S138.max = 60                # Maximum lines per method

# Class complexity (CRITICAL - 15 public members max)
dotnet_diagnostic.S1448.severity = error         # Classes should not have too many public methods
dotnet_code_quality.S1448.max = 15               # Maximum public members per class

# File length (enforced via MA0051 and custom MSBuild target)
# S2479 would be ideal but doesn't exist - using MA0051 instead

# ===================================================================
# NESTING DEPTH LIMIT - ERROR SEVERITY
# Prevents deeply nested control structures that harm readability.
# Maximum 3 levels of nesting enforced per standards.md.
# ===================================================================

dotnet_diagnostic.S134.severity = error          # Control flow statements should not be nested too deeply
dotnet_code_quality.S134.max = 3                 # Maximum nesting depth

# ===================================================================
# CODE SMELL DETECTION - ERROR SEVERITY
# Detects god classes, duplicate code, dead code, and other smells
# that violate SOLID principles and clean code standards.
# ===================================================================

# God classes and excessive complexity
dotnet_diagnostic.S1200.severity = error         # Classes should not be coupled to too many other classes
dotnet_code_quality.S1200.max = 20               # Maximum coupling (dependencies)

# Duplicate code detection (ZERO TOLERANCE per standards.md)
dotnet_diagnostic.S1192.severity = error         # String literals should not be duplicated
dotnet_code_quality.S1192.threshold = 3          # Minimum occurrences to trigger
dotnet_diagnostic.S4144.severity = error         # Methods should not have identical implementations
dotnet_diagnostic.S2326.severity = error         # Unused type parameters should be removed

# Dead code detection (MANDATORY cleanup)
dotnet_diagnostic.S1144.severity = error         # Unused private types or members should be removed
dotnet_diagnostic.S1481.severity = error         # Unused local variables should be removed
dotnet_diagnostic.S1854.severity = warning       # Unused assignments should be removed
dotnet_diagnostic.S1172.severity = warning       # Unused method parameters should be removed

# Empty blocks and statements
dotnet_diagnostic.S108.severity = error          # Nested blocks of code should not be left empty
dotnet_diagnostic.S1186.severity = error         # Methods should not be empty
dotnet_diagnostic.S2699.severity = warning       # Tests should include assertions

# Code organization and clarity
dotnet_diagnostic.S1066.severity = warning       # Mergeable if statements should be combined
dotnet_diagnostic.S1067.severity = warning       # Expressions should not be too complex
dotnet_code_quality.S1067.max = 3                # Maximum boolean operators per expression
dotnet_diagnostic.S1125.severity = warning       # Boolean literals should not be redundant
dotnet_diagnostic.S1135.severity = suggestion    # Track uses of TODO tags
dotnet_diagnostic.S1199.severity = warning       # Nested code blocks should not be used

# Magic numbers and hardcoded values
dotnet_diagnostic.S109.severity = warning        # Magic numbers should not be used
dotnet_diagnostic.S1075.severity = warning       # URIs should not be hardcoded

# Utility class design
dotnet_diagnostic.S1118.severity = error         # Utility classes should not have public constructors

# ===================================================================
# SECURITY RULES - ERROR SEVERITY (BUILD-BREAKING)
# All security vulnerabilities are treated as build failures.
# Zero tolerance for security issues per standards.md requirements.
# ===================================================================

# Credentials and secrets
dotnet_diagnostic.S2068.severity = error         # Credentials should not be hard-coded
dotnet_diagnostic.S6418.severity = error         # Hard-coded secrets should not be used

# Cryptography and random number generation
dotnet_diagnostic.S2245.severity = error         # Using pseudorandom number generators (PRNGs) is security-sensitive
dotnet_diagnostic.S4426.severity = error         # Cryptographic keys should be robust
dotnet_diagnostic.S5042.severity = error         # Expanding archive files without controlling resource consumption is security-sensitive
dotnet_diagnostic.S4790.severity = error         # Using weak hashing algorithms is security-sensitive
dotnet_diagnostic.S5547.severity = error         # Cipher algorithms should be robust

# Logic and control flow vulnerabilities
dotnet_diagnostic.S2583.severity = error         # Conditionally executed code should be reachable
dotnet_diagnostic.S2589.severity = warning       # Boolean expressions should not be gratuitous
dotnet_diagnostic.S2589.severity = warning       # Boolean expressions should not be gratuitous

# HTTP and network security
dotnet_diagnostic.S3330.severity = error         # HTTP cookies should be "secure"
dotnet_diagnostic.S5332.severity = error         # Using clear-text protocols is security-sensitive
dotnet_diagnostic.S4423.severity = error         # Weak SSL/TLS protocols should not be used
dotnet_diagnostic.S5122.severity = error         # Having a permissive Cross-Origin Resource Sharing policy is security-sensitive

# Injection vulnerabilities
dotnet_diagnostic.S2091.severity = error         # XPath expressions should not be vulnerable to injection attacks
dotnet_diagnostic.S2631.severity = error         # Regular expressions should not be vulnerable to Denial of Service attacks
dotnet_diagnostic.S3649.severity = error         # Database queries should not be vulnerable to injection attacks
dotnet_diagnostic.S5131.severity = error         # Endpoints should not be vulnerable to authorization bypass

# Additional security rules
dotnet_diagnostic.S4507.severity = error         # Delivering code in production with debug features activated is security-sensitive
dotnet_diagnostic.S5659.severity = error         # JWT should be signed and verified
dotnet_diagnostic.S6377.severity = error         # XML signatures should be validated securely

# ===================================================================
# EXCEPTION HANDLING - ERROR SEVERITY
# Enforces proper exception handling patterns per standards.md.
# Prevents empty catch blocks and generic exception catching.
# ===================================================================

# Empty catch blocks (FORBIDDEN)
dotnet_diagnostic.S2737.severity = error         # Catch clauses should do more than rethrow
dotnet_diagnostic.S1166.severity = error         # Exception handlers should preserve stack trace
dotnet_diagnostic.S2139.severity = warning       # Exceptions should not be thrown from property getters

# Generic exception catching (DISCOURAGED)
dotnet_diagnostic.S2221.severity = error         # "Exception" should not be caught when not required by called methods
dotnet_diagnostic.S112.severity = error          # General exceptions should never be thrown
dotnet_diagnostic.S3877.severity = warning       # Exceptions should not be explicitly rethrown

# Exception design
dotnet_diagnostic.S3925.severity = error         # "ISerializable" should be implemented correctly
dotnet_diagnostic.S4027.severity = warning       # Exceptions should provide standard constructors

# ===================================================================
# MAINTAINABILITY RULES - WARNING SEVERITY
# Encourages maintainable code through proper design patterns.
# Aligns with SOLID principles and composition over inheritance.
# ===================================================================

# Class and method design
dotnet_diagnostic.S1104.severity = error         # Fields should not have public accessibility
dotnet_diagnostic.S1450.severity = warning       # Private fields only used as local variables should become local variables
dotnet_diagnostic.S2094.severity = warning       # Classes should not be empty
dotnet_diagnostic.S2326.severity = error         # Unused type parameters should be removed
dotnet_diagnostic.S3881.severity = warning       # "IDisposable" should be implemented correctly
dotnet_diagnostic.S3971.severity = warning       # "GC.SuppressFinalize" should not be called

# Naming conventions
dotnet_diagnostic.S101.severity = warning        # Types should be named in PascalCase
dotnet_diagnostic.S100.severity = warning        # Methods and properties should be named in PascalCase
dotnet_diagnostic.S116.severity = warning        # Field names should comply with a naming convention
dotnet_diagnostic.S117.severity = warning        # Local variables should comply with a naming convention
dotnet_diagnostic.S2342.severity = warning       # Enumeration types should comply with a naming convention

# Code organization
dotnet_diagnostic.S1128.severity = warning       # Unused "using" should be removed
dotnet_diagnostic.S1133.severity = suggestion    # Deprecated code should be removed
dotnet_diagnostic.S1134.severity = suggestion    # Track uses of "FIXME" tags
dotnet_diagnostic.S1185.severity = warning       # Overriding members should do more than simply call the same member in the base class

# Type usage
dotnet_diagnostic.S1168.severity = warning       # Empty arrays and collections should be returned instead of null
dotnet_diagnostic.S2223.severity = warning       # Non-constant static fields should not be visible
dotnet_diagnostic.S2225.severity = warning       # "ToString()" method should not return null
dotnet_diagnostic.S2328.severity = warning       # "GetHashCode" should not reference mutable fields

# ===================================================================
# LINQ AND COLLECTION USAGE - WARNING SEVERITY
# Optimizes LINQ usage and prevents common collection mistakes.
# ===================================================================

dotnet_diagnostic.S2971.severity = warning       # "IEnumerable" LINQs should be simplified
dotnet_diagnostic.S3267.severity = warning       # Loops should be simplified with "LINQ" expressions
dotnet_diagnostic.S3358.severity = none          # Ternary operators should not be nested (allow for functional patterns)
dotnet_diagnostic.S3626.severity = error         # Jump statements should not be redundant
dotnet_diagnostic.S3869.severity = warning       # "SafeHandle.DangerousGetHandle" should not be called
dotnet_diagnostic.S3872.severity = warning       # Parameter names should not duplicate the names of their methods
dotnet_diagnostic.S3874.severity = warning       # "out" and "ref" parameters should not be used
dotnet_diagnostic.S3875.severity = warning       # "operator==" should not be overloaded on reference types
dotnet_diagnostic.S3876.severity = warning       # Strings should not be concatenated using '+' in a loop
dotnet_diagnostic.S3878.severity = warning       # Arrays should not be created for params parameters
dotnet_diagnostic.S3887.severity = warning       # Mutable, non-private fields should not be "readonly"
dotnet_diagnostic.S3889.severity = warning       # "Thread.Resume" and "Thread.Suspend" should not be used
dotnet_diagnostic.S3897.severity = warning       # Classes that provide "Equals(<T>)" should implement "IEquatable<T>"
dotnet_diagnostic.S3898.severity = warning       # Value types should implement "IEquatable<T>"

# ===================================================================
# ASYNC AND THREADING - WARNING SEVERITY
# Ensures proper async/await patterns and thread safety.
# ===================================================================

dotnet_diagnostic.S2190.severity = warning       # Recursion should not be infinite
dotnet_diagnostic.S2222.severity = error         # Locks should be released
dotnet_diagnostic.S2223.severity = warning       # Non-constant static fields should not be visible
dotnet_diagnostic.S3168.severity = warning       # "async" methods should not return "void"
dotnet_diagnostic.S3257.severity = warning       # Declarations and initializations should be as concise as possible
dotnet_diagnostic.S4457.severity = warning       # Parameter validation in "async"/"await" methods should be wrapped
dotnet_diagnostic.S4462.severity = warning       # Calls to "async" methods should not be blocking
dotnet_diagnostic.S4581.severity = warning       # "new Guid()" should not be used

# ===================================================================
# PERFORMANCE AND OPTIMIZATION - WARNING SEVERITY
# Identifies performance issues and suggests optimizations.
# ===================================================================

dotnet_diagnostic.S1643.severity = warning       # Strings should be concatenated using StringBuilder
dotnet_diagnostic.S1656.severity = warning       # Variables should not be self-assigned
dotnet_diagnostic.S1751.severity = warning       # Loops with at most one iteration should be refactored
dotnet_diagnostic.S2178.severity = warning       # Short-circuit logic should be used in boolean contexts
dotnet_diagnostic.S2184.severity = warning       # Results of integer division should not be assigned to floating point variables
dotnet_diagnostic.S2197.severity = warning       # Modulus results should not be checked for direct equality
dotnet_diagnostic.S2219.severity = warning       # Runtime type checking should be simplified
dotnet_diagnostic.S2234.severity = warning       # Parameters should be passed in the correct order
dotnet_diagnostic.S2251.severity = warning       # A "for" loop update clause should move the counter in the right direction
dotnet_diagnostic.S2259.severity = error         # Null pointers should not be dereferenced
dotnet_diagnostic.S2275.severity = warning       # Composite format strings should be used correctly
dotnet_diagnostic.S2290.severity = warning       # Field-like events should not be virtual
dotnet_diagnostic.S2291.severity = warning       # Overflow checking should not be disabled for "Enumerable.Sum"
dotnet_diagnostic.S2292.severity = warning       # Trivial properties should be auto-implemented
dotnet_diagnostic.S2302.severity = warning       # "nameof" should be used
dotnet_diagnostic.S2306.severity = warning       # "async" methods should not return "void"
dotnet_diagnostic.S2325.severity = warning       # Methods and properties that don't access instance data should be static
dotnet_diagnostic.S2327.severity = warning       # "try" statements with identical "catch" and/or "finally" blocks should be merged
dotnet_diagnostic.S2330.severity = warning       # Array covariance should not be used
dotnet_diagnostic.S2333.severity = warning       # Redundant modifiers should not be used
dotnet_diagnostic.S2344.severity = warning       # Enumeration members should not be named "Reserved"
dotnet_diagnostic.S2345.severity = warning       # Flags enumerations should explicitly initialize all their members
dotnet_diagnostic.S2346.severity = warning       # Flags enumerations zero-value members should be named "None"
dotnet_diagnostic.S2347.severity = warning       # Null should not be returned from a "Task" returning method
dotnet_diagnostic.S2357.severity = warning       # Fields should be private
dotnet_diagnostic.S2360.severity = warning       # Optional parameters should not be used
dotnet_diagnostic.S2365.severity = warning       # Properties should not make collection or array copies
dotnet_diagnostic.S2368.severity = warning       # Public methods should not have multidimensional array parameters
dotnet_diagnostic.S2372.severity = warning       # Exceptions should not be thrown from property getters
dotnet_diagnostic.S2376.severity = warning       # Write-only properties should not be used
dotnet_diagnostic.S2386.severity = warning       # Mutable fields should not be "public static"
dotnet_diagnostic.S2387.severity = warning       # Child class fields should not shadow parent class fields

# ===================================================================
# SONARANALYZER.CSHARP CONFIGURATION SUMMARY
# ===================================================================
#
# CONFIGURED RULES: 100+ rules explicitly configured
#
# ERROR SEVERITY (Build-breaking):
# - Cognitive complexity: S3776 (threshold: 15)
# - Method length: S138 (max: 60 lines)
# - Class complexity: S1448 (max: 15 public members)
# - Nesting depth: S134 (max: 3 levels)
# - Code smells: S1200, S1192, S4144, S2326, S1144, S1481, S108, S1186, S1118
# - Security: S2068, S2245, S2583, S3330, S4426, S5042, S6418, S4790, S5547, S5332, S4423, S5122, S2091, S2631, S3649, S5131, S4507, S5659, S6377
# - Exception handling: S2737, S1166, S2221, S112, S3925
# - Maintainability: S1104, S2326, S3626, S2222, S2259
#
# WARNING SEVERITY (Should fix before commit):
# - Code organization: S1066, S1067, S1125, S1199, S109, S1075, S1854, S1172
# - Maintainability: S1450, S2094, S3881, S3971, S101, S100, S116, S117, S2342
# - LINQ and collections: S2971, S3267, S3869, S3872, S3874-S3876, S3887, S3889, S3897-S3898
# - Async and threading: S2190, S2223, S3168, S3257, S4457, S4462, S4581
# - Performance: S1643, S1656, S1751, S2178, S2184, S2197, S2219, S2234, S2251, S2275, S2290-S2292, S2302, S2306, S2325, S2327, S2330, S2333, S2344-S2347, S2357, S2360, S2365, S2368, S2372, S2376, S2386-S2387
#
# SUGGESTION SEVERITY (Optional improvements):
# - Code tracking: S1135, S1133, S1134
#
# This configuration enforces cognitive complexity limits, detects code smells,
# prevents security vulnerabilities, and ensures maintainable code as required
# by standards.md and the advanced analyzer enforcement specification.
#
# ===================================================================

# ===================================================================
# ROSLYNATOR.ANALYZERS - COMPREHENSIVE CONFIGURATION
# Code Simplification, Refactoring, and C# 12 Feature Adoption
# ===================================================================
#
# Roslynator.Analyzers provides 200+ rules for code simplification,
# refactoring opportunities, and modern C# feature adoption. This
# configuration aligns with standards.md requirements:
#
# - CODE SIMPLIFICATION: Expression-bodied members, pattern matching
# - REFACTORING: Switch expressions, null-coalescing, string interpolation
# - C# 12 FEATURES: Collection expressions, file-scoped namespaces
# - LINQ OPTIMIZATION: Method preferences and inline declarations
# - MODERN C# IDIOMS: Target-typed new, range operators, using declarations
#
# Pattern matching and simplification rules are set to ERROR to enforce
# modern C# patterns. Refactoring suggestions are WARNING to encourage
# best practices. C# 12 feature adoption is MANDATORY (error severity).
#
# ===================================================================

# ===================================================================
# FILE-SCOPED NAMESPACES (C# 10+) - MANDATORY ERROR
# Enforces file-scoped namespace declarations per standards.md.
# This is already configured in the IDE rules section above, but
# Roslynator provides additional enforcement.
# ===================================================================
dotnet_diagnostic.RCS1194.severity = error       # Implement exception constructors (not file-scoped namespace)

# ===================================================================
# EXPRESSION-BODIED MEMBERS - WARNING SEVERITY
# Encourages expression-bodied members for single-expression implementations.
# Use judgment based on readability - not all methods benefit from expression bodies.
# ===================================================================
dotnet_diagnostic.RCS1016.severity = suggestion  # Use block body or expression body (configurable)
dotnet_diagnostic.RCS1021.severity = suggestion  # Convert lambda expression body to expression body

# ===================================================================
# PATTERN MATCHING - ERROR SEVERITY
# Enforces pattern matching over legacy type checking and casting.
# Pattern matching is safer, more concise, and aligns with functional principles.
# ===================================================================
dotnet_diagnostic.RCS1146.severity = error       # Use conditional access
dotnet_diagnostic.RCS1214.severity = error       # Unnecessary interpolated string
dotnet_diagnostic.RCS1233.severity = error       # Use short-circuiting operator
dotnet_diagnostic.RCS1220.severity = error       # Use pattern matching instead of combination of 'is' operator and cast operator
dotnet_diagnostic.RCS1221.severity = error       # Use pattern matching instead of combination of 'as' operator and null check
dotnet_diagnostic.RCS9001.severity = error       # Use pattern matching (Roslyn-specific)

# ===================================================================
# SWITCH EXPRESSIONS - ERROR SEVERITY
# Enforces switch expressions over if-else chains and switch statements.
# Switch expressions are more functional and prevent missing cases.
# ===================================================================
dotnet_diagnostic.RCS1003.severity = error       # Add braces to if-else (when expression spans over multiple lines)

# Note: RCS1003 is about braces, not switch expressions. There is no specific
# Roslynator rule for enforcing switch expressions over switch statements.
# This is handled by IDE rules (IDE0066) configured above.

# ===================================================================
# NULL-COALESCING AND NULL-CONDITIONAL OPERATORS - ERROR SEVERITY
# Enforces modern null-checking patterns and null-conditional operators.
# ===================================================================
dotnet_diagnostic.RCS1084.severity = error       # Use coalesce expression instead of conditional expression
dotnet_diagnostic.RCS1128.severity = error       # Use coalesce expression
dotnet_diagnostic.RCS1173.severity = error       # Use coalesce expression instead of 'if'
dotnet_diagnostic.RCS1143.severity = error       # Simplify coalesce expression
dotnet_diagnostic.RCS1199.severity = error       # Unnecessary null check
dotnet_diagnostic.RCS9005.severity = error       # Unnecessary null check (Roslyn-specific)

# ===================================================================
# STRING INTERPOLATION - WARNING SEVERITY
# Enforces string interpolation over concatenation and string.Format.
# ===================================================================
dotnet_diagnostic.RCS1197.severity = warning     # Optimize StringBuilder.Append/AppendLine call
dotnet_diagnostic.RCS1190.severity = warning     # Join string expressions
dotnet_diagnostic.RCS1105.severity = warning     # Unnecessary interpolation
dotnet_diagnostic.RCS1217.severity = suggestion  # Convert interpolated string to concatenation
dotnet_diagnostic.RCS1267.severity = warning     # Use string interpolation instead of 'string.Concat'

# ===================================================================
# LINQ PREFERENCES - WARNING SEVERITY
# Optimizes LINQ usage and prevents inefficient patterns.
# ===================================================================
dotnet_diagnostic.RCS1077.severity = warning     # Optimize LINQ method call
dotnet_diagnostic.RCS1112.severity = warning     # Combine 'Enumerable.Where' method chain
dotnet_diagnostic.RCS1200.severity = warning     # Call 'Enumerable.ThenBy' instead of 'Enumerable.OrderBy'
dotnet_diagnostic.RCS1235.severity = warning     # Optimize method call
dotnet_diagnostic.RCS9004.severity = warning     # Call 'Any' instead of accessing 'Count' (Roslyn-specific)

# ===================================================================
# INLINE VARIABLE DECLARATIONS - WARNING SEVERITY
# Encourages inline variable declarations for cleaner code.
# ===================================================================
dotnet_diagnostic.RCS1124.severity = warning     # Inline local variable
dotnet_diagnostic.RCS1180.severity = warning     # Inline lazy initialization

# ===================================================================
# COLLECTION EXPRESSIONS (C# 12) - ERROR SEVERITY
# Note: Roslynator does not have specific rules for C# 12 collection expressions.
# This is handled by IDE rules (IDE0300-IDE0305) configured above.
# ===================================================================

# ===================================================================
# SIMPLIFICATION RULES - WARNING SEVERITY
# Encourages code simplification for better readability and maintainability.
# ===================================================================
dotnet_diagnostic.RCS1032.severity = warning     # Remove redundant parentheses
dotnet_diagnostic.RCS1033.severity = warning     # Remove redundant boolean literal
dotnet_diagnostic.RCS1034.severity = warning     # Remove redundant 'sealed' modifier
dotnet_diagnostic.RCS1037.severity = warning     # Remove trailing white-space
dotnet_diagnostic.RCS1039.severity = warning     # Remove argument list from attribute
dotnet_diagnostic.RCS1042.severity = warning     # Remove enum default underlying type
dotnet_diagnostic.RCS1043.severity = warning     # Remove 'partial' modifier from type with a single part
dotnet_diagnostic.RCS1049.severity = warning     # Simplify boolean comparison
dotnet_diagnostic.RCS1068.severity = warning     # Simplify logical negation
dotnet_diagnostic.RCS1069.severity = warning     # Remove unnecessary case label
dotnet_diagnostic.RCS1070.severity = warning     # Remove redundant default switch section
dotnet_diagnostic.RCS1071.severity = warning     # Remove redundant base constructor call
dotnet_diagnostic.RCS1073.severity = warning     # Convert 'if' to 'return' statement
dotnet_diagnostic.RCS1074.severity = warning     # Remove redundant constructor
dotnet_diagnostic.RCS1097.severity = warning     # Remove redundant 'ToString' call
dotnet_diagnostic.RCS1103.severity = warning     # Convert 'if' to assignment
dotnet_diagnostic.RCS1104.severity = warning     # Simplify conditional expression
dotnet_diagnostic.RCS1107.severity = warning     # Remove redundant 'ToCharArray' call
dotnet_diagnostic.RCS1114.severity = warning     # Remove redundant delegate creation
dotnet_diagnostic.RCS1129.severity = warning     # Remove redundant field initialization
dotnet_diagnostic.RCS1132.severity = warning     # Remove redundant overriding member
dotnet_diagnostic.RCS1133.severity = warning     # Remove redundant Dispose/Close call
dotnet_diagnostic.RCS1134.severity = warning     # Remove redundant statement
dotnet_diagnostic.RCS1145.severity = warning     # Remove redundant 'as' operator
dotnet_diagnostic.RCS1151.severity = warning     # Remove redundant cast
dotnet_diagnostic.RCS1179.severity = warning     # Unnecessary assignment
dotnet_diagnostic.RCS1182.severity = warning     # Remove redundant base interface
dotnet_diagnostic.RCS1188.severity = warning     # Remove redundant auto-property initialization
dotnet_diagnostic.RCS1192.severity = warning     # Unnecessary usage of verbatim string literal
dotnet_diagnostic.RCS1211.severity = warning     # Remove unnecessary 'else'
dotnet_diagnostic.RCS1212.severity = warning     # Remove redundant assignment
dotnet_diagnostic.RCS1216.severity = warning     # Unnecessary unsafe context
dotnet_diagnostic.RCS1218.severity = warning     # Simplify code branching
dotnet_diagnostic.RCS1240.severity = warning     # Operator is unnecessary
dotnet_diagnostic.RCS1244.severity = warning     # Simplify 'default' expression
dotnet_diagnostic.RCS1249.severity = warning     # Unnecessary null-forgiving operator
dotnet_diagnostic.RCS1251.severity = warning     # Remove unnecessary braces from record declaration
dotnet_diagnostic.RCS1259.severity = warning     # Remove empty syntax
dotnet_diagnostic.RCS1262.severity = warning     # Unnecessary raw string literal
dotnet_diagnostic.RCS1265.severity = warning     # Remove redundant catch block
dotnet_diagnostic.RCS1268.severity = warning     # Simplify numeric comparison

# ===================================================================
# REFACTORING SUGGESTIONS - WARNING SEVERITY
# Suggests refactoring opportunities for better code organization.
# ===================================================================
dotnet_diagnostic.RCS1005.severity = warning     # Simplify nested using statement
dotnet_diagnostic.RCS1006.severity = warning     # Merge 'else' with nested 'if'
dotnet_diagnostic.RCS1031.severity = warning     # Remove unnecessary braces in switch section
dotnet_diagnostic.RCS1061.severity = warning     # Merge 'if' with nested 'if'
dotnet_diagnostic.RCS1085.severity = warning     # Use auto-implemented property
dotnet_diagnostic.RCS1089.severity = warning     # Use --/++ operator instead of assignment
dotnet_diagnostic.RCS1102.severity = warning     # Make class static
dotnet_diagnostic.RCS1136.severity = warning     # Merge switch sections with equivalent content
dotnet_diagnostic.RCS1171.severity = warning     # Simplify lazy initialization
dotnet_diagnostic.RCS1174.severity = suggestion  # Remove redundant async/await (can break semantics)
dotnet_diagnostic.RCS1186.severity = warning     # Use Regex instance instead of static method
dotnet_diagnostic.RCS1187.severity = warning     # Use constant instead of field
dotnet_diagnostic.RCS1196.severity = warning     # Call extension method as instance method
dotnet_diagnostic.RCS1201.severity = suggestion  # Use method chaining
dotnet_diagnostic.RCS1206.severity = warning     # Use conditional access instead of conditional expression
dotnet_diagnostic.RCS1208.severity = suggestion  # Reduce 'if' nesting
dotnet_diagnostic.RCS1222.severity = warning     # Merge preprocessor directives
dotnet_diagnostic.RCS1224.severity = suggestion  # Make method an extension method
dotnet_diagnostic.RCS1225.severity = warning     # Make class sealed (composition over inheritance)
dotnet_diagnostic.RCS1230.severity = warning     # Unnecessary explicit use of enumerator
dotnet_diagnostic.RCS1239.severity = warning     # Use 'for' statement instead of 'while' statement

# ===================================================================
# MODERN C# FEATURE ADOPTION - WARNING/ERROR SEVERITY
# Encourages adoption of modern C# features for cleaner code.
# ===================================================================

# Nameof operator (C# 6+)
dotnet_diagnostic.RCS1015.severity = error       # Use nameof operator

# Nullable<T> simplification (C# 2+)
dotnet_diagnostic.RCS1020.severity = warning     # Simplify Nullable<T> to T?

# Lambda expressions (C# 3+)
dotnet_diagnostic.RCS1048.severity = warning     # Use lambda expression instead of anonymous method

# Auto-properties (C# 3+)
dotnet_diagnostic.RCS1085.severity = warning     # Use auto-implemented property

# String.IsNullOrEmpty (best practice)
dotnet_diagnostic.RCS1113.severity = warning     # Use 'string.IsNullOrEmpty' method

# Const local variables (best practice)
dotnet_diagnostic.RCS1118.severity = warning     # Mark local variable as const

# Read-only fields and properties (immutability)
dotnet_diagnostic.RCS1169.severity = warning     # Make field read-only
dotnet_diagnostic.RCS1170.severity = warning     # Use read-only auto-implemented property

# Target-typed new (C# 9+)
dotnet_diagnostic.RCS1250.severity = suggestion  # Use implicit/explicit object creation (configurable)

# Range and index operators (C# 8+)
dotnet_diagnostic.RCS1195.severity = warning     # Use ^ operator

# Raw string literals (C# 11+)
dotnet_diagnostic.RCS1266.severity = suggestion  # Use raw string literal

# ===================================================================
# CODE QUALITY AND MAINTAINABILITY - WARNING SEVERITY
# Enforces code quality standards and prevents common mistakes.
# ===================================================================

# Naming conventions
dotnet_diagnostic.RCS1046.severity = warning     # Asynchronous method name should end with 'Async'
dotnet_diagnostic.RCS1047.severity = warning     # Non-asynchronous method name should not end with 'Async'

# Exception handling
dotnet_diagnostic.RCS1044.severity = error       # Remove original exception from throw statement
dotnet_diagnostic.RCS1075.severity = error       # Avoid empty catch clause that catches System.Exception
dotnet_diagnostic.RCS1210.severity = error       # Return completed task instead of returning null
dotnet_diagnostic.RCS1227.severity = warning     # Validate arguments correctly
dotnet_diagnostic.RCS1236.severity = warning     # Use exception filter

# Async/await patterns
dotnet_diagnostic.RCS1090.severity = none        # Add/remove 'ConfigureAwait(false)' call (handled by MA0004)
dotnet_diagnostic.RCS1229.severity = warning     # Use async/await when necessary

# Threading and locking
dotnet_diagnostic.RCS1059.severity = error       # Avoid locking on publicly accessible instance

# Enum patterns
dotnet_diagnostic.RCS1130.severity = warning     # Bitwise operation on enum without Flags attribute
dotnet_diagnostic.RCS1135.severity = warning     # Declare enum member with zero value (when enum has FlagsAttribute)
dotnet_diagnostic.RCS1154.severity = warning     # Sort enum members
dotnet_diagnostic.RCS1157.severity = warning     # Composite enum value contains undefined flag
dotnet_diagnostic.RCS1161.severity = suggestion  # Enum should declare explicit values
dotnet_diagnostic.RCS1191.severity = warning     # Declare enum value as combination of names
dotnet_diagnostic.RCS1234.severity = warning     # Duplicate enum value
dotnet_diagnostic.RCS1254.severity = warning     # Normalize format of enum flag value
dotnet_diagnostic.RCS1257.severity = warning     # Use enum field explicitly
dotnet_diagnostic.RCS1258.severity = warning     # Unnecessary enum flag

# Type design
dotnet_diagnostic.RCS1158.severity = warning     # Static member in generic type should use a type parameter
dotnet_diagnostic.RCS1159.severity = warning     # Use EventHandler<T>
dotnet_diagnostic.RCS1160.severity = warning     # Abstract type should not have public constructors
dotnet_diagnostic.RCS1193.severity = error       # Overriding member should not change 'params' modifier
dotnet_diagnostic.RCS1203.severity = error       # Use AttributeUsageAttribute
dotnet_diagnostic.RCS1204.severity = warning     # Use EventArgs.Empty
dotnet_diagnostic.RCS1241.severity = suggestion  # Implement non-generic counterpart
dotnet_diagnostic.RCS1242.severity = error       # Do not pass non-read-only struct by read-only reference

# Parameter and argument handling
dotnet_diagnostic.RCS1163.severity = warning     # Unused parameter
dotnet_diagnostic.RCS1164.severity = warning     # Unused type parameter
dotnet_diagnostic.RCS1165.severity = warning     # Unconstrained type parameter checked for null
dotnet_diagnostic.RCS1166.severity = warning     # Value type object is never equal to null
dotnet_diagnostic.RCS1168.severity = suggestion  # Parameter name differs from base name
dotnet_diagnostic.RCS1175.severity = warning     # Unused 'this' parameter
dotnet_diagnostic.RCS1205.severity = warning     # Order named arguments according to the order of parameters
dotnet_diagnostic.RCS1209.severity = warning     # Order type parameter constraints
dotnet_diagnostic.RCS1231.severity = suggestion  # Make parameter ref read-only

# Unused code detection
dotnet_diagnostic.RCS1213.severity = warning     # Remove unused member declaration

# Comparison and equality
dotnet_diagnostic.RCS1098.severity = warning     # Constant values should be placed on right side of comparisons
dotnet_diagnostic.RCS1099.severity = warning     # Default label should be the last label in a switch section
dotnet_diagnostic.RCS1155.severity = error       # Use StringComparison when comparing strings
dotnet_diagnostic.RCS1156.severity = warning     # Use string.Length instead of comparison with empty string
dotnet_diagnostic.RCS1215.severity = error       # Expression is always equal to true/false
dotnet_diagnostic.RCS1248.severity = suggestion  # Normalize null check

# Performance optimizations
dotnet_diagnostic.RCS1080.severity = warning     # Use 'Count/Length' property instead of 'Any' method
dotnet_diagnostic.RCS1096.severity = suggestion  # Use 'HasFlag' method or bitwise operator
dotnet_diagnostic.RCS1198.severity = warning     # Avoid unnecessary boxing of value type
dotnet_diagnostic.RCS1202.severity = warning     # Avoid NullReferenceException
dotnet_diagnostic.RCS1246.severity = warning     # Use element access
dotnet_diagnostic.RCS9006.severity = warning     # Use element access (Roslyn-specific)
dotnet_diagnostic.RCS9008.severity = warning     # Call 'Last' instead of using [] (Roslyn-specific)

# ===================================================================
# DOCUMENTATION COMMENTS - WARNING SEVERITY
# Enforces XML documentation standards per standards.md requirements.
# ===================================================================
dotnet_diagnostic.RCS1138.severity = warning     # Add summary to documentation comment
dotnet_diagnostic.RCS1139.severity = warning     # Add summary element to documentation comment
dotnet_diagnostic.RCS1140.severity = none        # Add exception to documentation comment (not required per standards.md)
dotnet_diagnostic.RCS1141.severity = none        # Add 'param' element to documentation comment (not required per standards.md)
dotnet_diagnostic.RCS1142.severity = none        # Add 'typeparam' element to documentation comment (not required per standards.md)
dotnet_diagnostic.RCS1181.severity = suggestion  # Convert comment to documentation comment
dotnet_diagnostic.RCS1226.severity = suggestion  # Add paragraph to documentation comment
dotnet_diagnostic.RCS1228.severity = warning     # Unused element in a documentation comment
dotnet_diagnostic.RCS1232.severity = warning     # Order elements in documentation comment
dotnet_diagnostic.RCS1243.severity = warning     # Duplicate word in a comment
dotnet_diagnostic.RCS1247.severity = warning     # Fix documentation comment tag
dotnet_diagnostic.RCS1253.severity = suggestion  # Format documentation comment summary
dotnet_diagnostic.RCS1263.severity = error       # Invalid reference in a documentation comment

# ===================================================================
# CODE ORGANIZATION - SUGGESTION/WARNING SEVERITY
# Encourages consistent code organization and file structure.
# ===================================================================
dotnet_diagnostic.RCS1018.severity = suggestion  # Add/remove accessibility modifiers
dotnet_diagnostic.RCS1019.severity = warning     # Order modifiers
dotnet_diagnostic.RCS1050.severity = suggestion  # Include/omit parentheses when creating new object
dotnet_diagnostic.RCS1051.severity = suggestion  # Add/remove parentheses from condition in conditional operator
dotnet_diagnostic.RCS1052.severity = suggestion  # Declare each attribute separately
dotnet_diagnostic.RCS1055.severity = warning     # Unnecessary semicolon at the end of declaration
dotnet_diagnostic.RCS1056.severity = none        # Avoid usage of using alias directive (allow)
dotnet_diagnostic.RCS1060.severity = none        # Declare each type in separate file (not enforced)
dotnet_diagnostic.RCS1078.severity = suggestion  # Use "" or 'string.Empty' (configurable)
dotnet_diagnostic.RCS1081.severity = suggestion  # Split variable declaration
dotnet_diagnostic.RCS1093.severity = warning     # File contains no code
dotnet_diagnostic.RCS1094.severity = suggestion  # Declare using directive on top level
dotnet_diagnostic.RCS1108.severity = warning     # Add 'static' modifier to all partial class declarations
dotnet_diagnostic.RCS1110.severity = warning     # Declare type inside namespace
dotnet_diagnostic.RCS1189.severity = suggestion  # Add or remove region name
dotnet_diagnostic.RCS1260.severity = suggestion  # Add/remove trailing comma
dotnet_diagnostic.RCS1264.severity = none        # Use 'var' or explicit type (handled by IDE rules)

# ===================================================================
# ADVANCED PATTERNS - SUGGESTION SEVERITY
# Suggests advanced patterns for specific scenarios.
# ===================================================================
dotnet_diagnostic.RCS1058.severity = warning     # Use compound assignment
dotnet_diagnostic.RCS1123.severity = warning     # Add parentheses when necessary
dotnet_diagnostic.RCS1162.severity = suggestion  # Avoid chain of assignments
dotnet_diagnostic.RCS1223.severity = none        # Mark publicly visible type with DebuggerDisplay attribute (not required)
dotnet_diagnostic.RCS1238.severity = suggestion  # Avoid nested ?: operators
dotnet_diagnostic.RCS1252.severity = suggestion  # Normalize usage of infinite loop
dotnet_diagnostic.RCS1255.severity = suggestion  # Simplify argument null check
dotnet_diagnostic.RCS1256.severity = warning     # Invalid argument null check
dotnet_diagnostic.RCS1261.severity = suggestion  # Resource can be disposed asynchronously

# ===================================================================
# BRACES AND FORMATTING - DISABLED
# Braces and formatting rules are handled by RCS0xxx formatting analyzers
# and IDE formatting rules configured above. These rules are disabled to
# avoid conflicts and maintain consistency with existing formatting config.
# ===================================================================
dotnet_diagnostic.RCS1001.severity = none        # Add braces (when expression spans over multiple lines)
dotnet_diagnostic.RCS1002.severity = none        # Remove braces
dotnet_diagnostic.RCS1003.severity = none        # Add braces to if-else (when expression spans over multiple lines)
dotnet_diagnostic.RCS1004.severity = none        # Remove braces from if-else
dotnet_diagnostic.RCS1007.severity = none        # Add braces
dotnet_diagnostic.RCS1111.severity = none        # Add braces to switch section with multiple statements
dotnet_diagnostic.RCS1126.severity = none        # Add braces to if-else

# ===================================================================
# PREDEFINED TYPE USAGE - DISABLED
# Predefined type usage is handled by IDE0049 configured above.
# ===================================================================
dotnet_diagnostic.RCS1013.severity = none        # Use predefined type

# ===================================================================
# ARRAY TYPE SPECIFICATION - DISABLED
# Array type specification is handled by IDE rules and explicit typing requirements.
# ===================================================================
dotnet_diagnostic.RCS1014.severity = none        # Use explicitly/implicitly typed array

# ===================================================================
# THROWING NOTIMPLEMENTEDEXCEPTION - DISABLED
# Throwing NotImplementedException is sometimes necessary during development.
# ===================================================================
dotnet_diagnostic.RCS1079.severity = none        # Throwing of new NotImplementedException

# ===================================================================
# ROSLYN-SPECIFIC ANALYZERS (RCS9xxx) - INFO/WARNING SEVERITY
# These analyzers are suitable for projects that reference Roslyn packages.
# They are enabled at lower severity since not all projects use Roslyn APIs.
# ===================================================================
dotnet_diagnostic.RCS9002.severity = suggestion  # Use property SyntaxNode.SpanStart
dotnet_diagnostic.RCS9003.severity = suggestion  # Unnecessary conditional access
dotnet_diagnostic.RCS9007.severity = warning     # Use return value
dotnet_diagnostic.RCS9009.severity = warning     # Unknown language name
dotnet_diagnostic.RCS9010.severity = none        # Specify ExportCodeRefactoringProviderAttribute.Name
dotnet_diagnostic.RCS9011.severity = none        # Specify ExportCodeFixProviderAttribute.Name

# ===================================================================
# ROSLYNATOR CONFIGURATION SUMMARY
# ===================================================================
#
# CONFIGURED RULES: 150+ rules explicitly configured
#
# ERROR SEVERITY (Build-breaking):
# - Pattern matching: RCS1146, RCS1214, RCS1233, RCS1220, RCS1221, RCS9001
# - Null-coalescing: RCS1084, RCS1128, RCS1173, RCS1143, RCS1199, RCS9005
# - Nameof operator: RCS1015
# - Exception handling: RCS1044, RCS1075, RCS1210
# - String comparison: RCS1155
# - Boolean expressions: RCS1215
# - Type design: RCS1193, RCS1203, RCS1242
# - Documentation: RCS1263
# - Threading: RCS1059
#
# WARNING SEVERITY (Should fix before commit):
# - Simplification: 40+ rules for code simplification
# - Refactoring: 20+ rules for refactoring opportunities
# - Modern C# features: 15+ rules for feature adoption
# - Code quality: 30+ rules for maintainability
# - Documentation: RCS1138, RCS1139, RCS1228, RCS1232, RCS1243, RCS1247
# - LINQ optimization: RCS1077, RCS1112, RCS1200, RCS1235, RCS9004
# - String operations: RCS1197, RCS1190, RCS1105, RCS1267
# - Performance: RCS1080, RCS1198, RCS1202, RCS1246, RCS9006, RCS9008
#
# SUGGESTION SEVERITY (Optional improvements):
# - Expression-bodied members: RCS1016, RCS1021
# - Code organization: 15+ rules for consistent organization
# - Advanced patterns: 10+ rules for specific scenarios
#
# This configuration enforces modern C# patterns, code simplification,
# and refactoring opportunities as required by standards.md and the
# advanced analyzer enforcement specification.
#
# ===================================================================

# ===================================================================
# IDISPOSABLEANALYZERS - COMPREHENSIVE DISPOSAL PATTERN ENFORCEMENT
# ===================================================================
#
# IDisposableAnalyzers enforces deterministic resource management and
# proper disposal patterns as required by standards.md requirement 7
# and design.md section 5 (IDisposableAnalyzers Configuration Module).
#
# DISPOSAL PHILOSOPHY:
# - All IDisposable resources MUST be disposed in all code paths
# - Prefer using declarations (C# 8+) for automatic disposal
# - Never dispose injected dependencies (DI pattern)
# - Implement IAsyncDisposable for async resources
# - Seal classes that don't provide virtual disposal methods
#
# SEVERITY LEVELS:
# - ERROR: Core disposal violations that cause resource leaks
# - WARNING: Async disposal patterns and best practices
# - SUGGESTION: Using statement preferences and optimizations
#
# ===================================================================

# ===================================================================
# CORE DISPOSAL RULES - ERROR SEVERITY
# These rules prevent resource leaks and ensure proper disposal.
# All violations are build-breaking per requirements.md 7.1-7.5.
# ===================================================================

# IDISP001: Dispose created
# Ensures that IDisposable instances created in a method are properly disposed.
# Example violation: var stream = new MemoryStream(); // Never disposed
# Example fix: using var stream = new MemoryStream();
dotnet_diagnostic.IDISP001.severity = error

# IDISP002: Dispose member
# Ensures that IDisposable member fields are disposed in the class's Dispose method.
# Example violation: private readonly FileStream _stream; // Never disposed in Dispose()
# Example fix: Implement IDisposable and dispose _stream in Dispose() method
dotnet_diagnostic.IDISP002.severity = error

# IDISP003: Dispose previous before re-assigning
# Ensures disposal of existing instance before reassigning a field/variable.
# Example violation: _stream = new FileStream(...); // Previous _stream not disposed
# Example fix: _stream?.Dispose(); _stream = new FileStream(...);
dotnet_diagnostic.IDISP003.severity = error

# IDISP004: Don't ignore created IDisposable
# Prevents creating IDisposable instances and discarding them without disposal.
# Example violation: new MemoryStream().Write(...); // Stream created and lost
# Example fix: using var stream = new MemoryStream(); stream.Write(...);
dotnet_diagnostic.IDISP004.severity = error

# IDISP006: Implement IDisposable
# Suggests implementing IDisposable when a class owns disposable fields.
# Example violation: class Foo { private FileStream _stream; } // No IDisposable
# Example fix: class Foo : IDisposable { private FileStream _stream; public void Dispose() => _stream?.Dispose(); }
dotnet_diagnostic.IDISP006.severity = error

# IDISP007: Don't dispose injected
# Prevents disposing objects received via constructor/method parameters (DI pattern).
# Example violation: public Foo(IDisposable dep) { _dep = dep; } void Dispose() => _dep.Dispose(); // Wrong!
# Example fix: Don't dispose _dep - caller owns its lifetime
dotnet_diagnostic.IDISP007.severity = error

# IDISP008: Don't assign member with injected and created disposables
# Prevents confusion about disposal responsibility when mixing injected and created instances.
# Example violation: _stream = injected ?? new FileStream(...); // Unclear who disposes
# Example fix: Separate fields for injected vs created, or document ownership clearly
dotnet_diagnostic.IDISP008.severity = error

# IDISP009: Add IDisposable interface
# Suggests adding IDisposable interface when Dispose method exists but interface is missing.
# Example violation: class Foo { public void Dispose() { } } // Missing interface
# Example fix: class Foo : IDisposable { public void Dispose() { } }
dotnet_diagnostic.IDISP009.severity = error

# IDISP010: Call base.Dispose(disposing)
# Ensures proper disposal pattern in inheritance hierarchies.
# Example violation: protected override void Dispose(bool disposing) { /* no base call */ }
# Example fix: protected override void Dispose(bool disposing) { base.Dispose(disposing); }
dotnet_diagnostic.IDISP010.severity = error

# IDISP011: Don't return disposed instance
# Prevents returning instances that have already been disposed.
# Example violation: _stream.Dispose(); return _stream; // Returning disposed object
# Example fix: Don't dispose before returning, or return null/throw exception
dotnet_diagnostic.IDISP011.severity = error

# IDISP016: Don't use disposed instance
# Prevents accessing disposed resources.
# Example violation: stream.Dispose(); stream.Read(...); // Using after disposal
# Example fix: Don't access after disposal, restructure code flow
dotnet_diagnostic.IDISP016.severity = error

# IDISP018: Call SuppressFinalize
# Ensures GC.SuppressFinalize is called in Dispose method.
# Example violation: public void Dispose() { /* no GC.SuppressFinalize(this) */ }
# Example fix: public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
dotnet_diagnostic.IDISP018.severity = error

# IDISP019: Call SuppressFinalize
# Variant of IDISP018 for different disposal patterns.
dotnet_diagnostic.IDISP019.severity = error

# IDISP020: Call SuppressFinalize(this)
# Ensures correct syntax for GC.SuppressFinalize call.
# Example violation: GC.SuppressFinalize(); // Missing 'this' parameter
# Example fix: GC.SuppressFinalize(this);
dotnet_diagnostic.IDISP020.severity = error

# IDISP021: Call this.Dispose(true)
# Ensures proper call to Dispose(bool) overload from public Dispose().
# Example violation: public void Dispose() { Dispose(false); } // Wrong parameter
# Example fix: public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
dotnet_diagnostic.IDISP021.severity = error

# IDISP022: Call this.Dispose(false)
# Ensures proper call to Dispose(bool) from finalizer.
# Example violation: ~Foo() { Dispose(true); } // Wrong parameter in finalizer
# Example fix: ~Foo() { Dispose(false); }
dotnet_diagnostic.IDISP022.severity = error

# IDISP023: Don't use reference types in finalizer context
# Prevents accessing reference types in finalizers (unsafe due to GC ordering).
# Example violation: ~Foo() { _stream.Dispose(); } // Reference type in finalizer
# Example fix: Only dispose unmanaged resources in finalizer, use Dispose(bool) pattern
dotnet_diagnostic.IDISP023.severity = error

# ===================================================================
# ASYNC DISPOSAL RULES - WARNING SEVERITY
# These rules enforce async disposal patterns for async resources.
# Set to warning to encourage adoption without blocking builds.
# ===================================================================

# IDISP025: Class with no virtual dispose method should be sealed
# Ensures classes are sealed if they don't provide virtual disposal for inheritance.
# Example violation: public class Foo : IDisposable { public void Dispose() { } } // Not sealed, not virtual
# Example fix: public sealed class Foo : IDisposable { public void Dispose() { } }
# Rationale: Aligns with composition-over-inheritance and sealed-by-default principles
dotnet_diagnostic.IDISP025.severity = warning

# IDISP026: Class with no virtual DisposeAsyncCore method should be sealed
# Ensures classes implementing IAsyncDisposable are sealed if no virtual async disposal.
# Example violation: public class Foo : IAsyncDisposable { public ValueTask DisposeAsync() { } } // Not sealed
# Example fix: public sealed class Foo : IAsyncDisposable { public ValueTask DisposeAsync() { } }
dotnet_diagnostic.IDISP026.severity = warning

# ===================================================================
# USING STATEMENT PATTERNS - WARNING SEVERITY
# These rules encourage modern using patterns and best practices.
# ===================================================================

# IDISP013: Await in using
# Warns about awaiting disposables in using blocks (potential issues).
# Example violation: using (var x = await GetAsync()) { await x.ProcessAsync(); }
# Example fix: Consider using await using pattern or restructure
dotnet_diagnostic.IDISP013.severity = warning

# IDISP017: Prefer using
# Encourages use of using statement/declaration for IDisposable objects.
# Example violation: var stream = new FileStream(...); try { } finally { stream.Dispose(); }
# Example fix: using var stream = new FileStream(...);
dotnet_diagnostic.IDISP017.severity = warning

# ===================================================================
# DISPOSAL SCOPE AND FACTORY PATTERNS - WARNING SEVERITY
# These rules prevent common disposal mistakes in specific scenarios.
# ===================================================================

# IDISP005: Return type should indicate that the value should be disposed
# Warns when factory methods return IDisposable without clear ownership indication.
# Example violation: public Stream Create() => new MemoryStream(); // Unclear who disposes
# Example fix: Document ownership, or return IDisposable explicitly to signal disposal responsibility
dotnet_diagnostic.IDISP005.severity = warning

# IDISP012: Property should not return created disposable
# Prevents properties from returning freshly created disposable objects.
# Example violation: public Stream Data => new MemoryStream(); // New instance each call
# Example fix: Use method instead: public Stream CreateData() => new MemoryStream();
dotnet_diagnostic.IDISP012.severity = warning

# IDISP015: Member should not return created and cached instance
# Prevents returning cached disposable instances that may be disposed elsewhere.
# Example violation: public Stream GetStream() => _cachedStream ??= new FileStream(...);
# Example fix: Clarify ownership and disposal responsibility
dotnet_diagnostic.IDISP015.severity = warning

# ===================================================================
# SPECIFIC RESOURCE PATTERNS - WARNING SEVERITY
# These rules handle specific disposal scenarios and best practices.
# ===================================================================

# IDISP014: Use a single instance of HttpClient
# Encourages singleton HttpClient pattern to avoid socket exhaustion.
# Example violation: using var client = new HttpClient(); // Created per request
# Example fix: Use static/singleton HttpClient instance
dotnet_diagnostic.IDISP014.severity = warning

# IDISP024: Don't call GC.SuppressFinalize(this) when the type is sealed and has no finalizer
# Prevents unnecessary GC.SuppressFinalize calls in sealed types without finalizers.
# Example violation: public sealed class Foo : IDisposable { public void Dispose() { GC.SuppressFinalize(this); } } // No finalizer
# Example fix: Remove GC.SuppressFinalize(this) call when sealed and no finalizer exists
dotnet_diagnostic.IDISP024.severity = warning

# ===================================================================
# ASYNC DISPOSAL PATTERNS - SUGGESTION SEVERITY
# These rules suggest async disposal improvements without enforcing them.
# ===================================================================

# IDISP261: Resource can be disposed asynchronously (Roslynator rule)
# Suggests using async disposal when available.
# Example: using var stream = new FileStream(...); // Could use await using
# Note: This is RCS1261, included here for completeness
# Configured in Roslynator section above

# ===================================================================
# IDISPOSABLEANALYZERS CONFIGURATION SUMMARY
# ===================================================================
#
# CONFIGURED RULES: 26 disposal rules explicitly configured
#
# ERROR SEVERITY (Build-breaking - Core Disposal):
# - IDISP001: Dispose created instances
# - IDISP002: Dispose member fields
# - IDISP003: Dispose previous before re-assigning
# - IDISP004: Don't ignore created IDisposable
# - IDISP006: Implement IDisposable interface
# - IDISP007: Don't dispose injected dependencies (DI pattern)
# - IDISP008: Don't mix injected and created disposables
# - IDISP009: Add IDisposable interface
# - IDISP010: Call base.Dispose(disposing)
# - IDISP011: Don't return disposed instance
# - IDISP016: Don't use disposed instance
# - IDISP018-023: Proper disposal pattern implementation
#
# WARNING SEVERITY (Async Disposal & Best Practices):
# - IDISP025: Seal classes without virtual dispose
# - IDISP026: Seal classes without virtual DisposeAsyncCore
# - IDISP013: Await in using blocks
# - IDISP017: Prefer using statements
# - IDISP005: Return type disposal indication
# - IDISP012: Properties shouldn't return created disposables
# - IDISP015: Cached instance disposal clarity
# - IDISP014: HttpClient singleton pattern
# - IDISP024: Unnecessary SuppressFinalize calls
#
# DISPOSAL PATTERN EXAMPLES:
#
# 1. Simple Disposal (using declaration - C# 8+):
#    public void Process()
#    {
#        using var stream = new FileStream("data.txt", FileMode.Open);
#        // stream automatically disposed at end of scope
#    }
#
# 2. Class with Disposable Members:
#    public sealed class DataProcessor : IDisposable
#    {
#        private readonly FileStream _stream;
#        
#        public DataProcessor(string path)
#        {
#            _stream = new FileStream(path, FileMode.Open);
#        }
#        
#        public void Dispose()
#        {
#            _stream?.Dispose();
#        }
#    }
#
# 3. Dependency Injection (Don't Dispose Injected):
#    public sealed class Service
#    {
#        private readonly ILogger _logger; // Injected - don't dispose
#        
#        public Service(ILogger logger)
#        {
#            _logger = logger;
#        }
#        
#        // No Dispose() - we don't own _logger
#    }
#
# 4. Async Disposal (C# 8+):
#    public sealed class AsyncProcessor : IAsyncDisposable
#    {
#        private readonly Stream _stream;
#        
#        public async ValueTask DisposeAsync()
#        {
#            if (_stream != null)
#                await _stream.DisposeAsync();
#        }
#    }
#
# 5. Full Disposal Pattern (with finalizer):
#    public class ResourceHolder : IDisposable
#    {
#        private IntPtr _unmanagedResource;
#        private FileStream _managedResource;
#        private bool _disposed;
#        
#        ~ResourceHolder()
#        {
#            Dispose(false);
#        }
#        
#        public void Dispose()
#        {
#            Dispose(true);
#            GC.SuppressFinalize(this);
#        }
#        
#        protected virtual void Dispose(bool disposing)
#        {
#            if (_disposed) return;
#            
#            if (disposing)
#            {
#                // Dispose managed resources
#                _managedResource?.Dispose();
#            }
#            
#            // Free unmanaged resources
#            if (_unmanagedResource != IntPtr.Zero)
#            {
#                // Free unmanaged resource
#                _unmanagedResource = IntPtr.Zero;
#            }
#            
#            _disposed = true;
#        }
#    }
#
# This configuration enforces deterministic resource management and
# proper disposal patterns as required by standards.md and aligns with
# the functional programming principle of explicit resource lifetime management.
#
# ===================================================================
