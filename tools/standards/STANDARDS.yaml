# STANDARDS.yaml - Single Source of Truth for Parametric Arsenal Coding Standards
# Version: 1.0
# Purpose: Machine-readable standard definitions for StandardsGen.csx generator
# Target: Generates CLAUDE.md, copilot-instructions.md, and *.agent.md [CRITICAL RULES] sections

version: "1.0"
last_updated: "2025-11-26"
repository: "bsamiee/Parametric_Arsenal"

# Mandatory coding rules enforced by analyzers
rules:
  syntax:
    - id: NO_VAR
      severity: error
      analyzer: IDE0007
      category: syntax
      description: "No var keyword - always use explicit types"
      rationale: "Improves code clarity and prevents type ambiguity"
      example_wrong: "var x = new RTree();"
      example_correct: "RTree x = new();"
      
    - id: NO_IF_ELSE
      severity: error
      category: syntax
      description: "Use expressions only - no if/else statements"
      rationale: "Expressions compose better and encourage functional thinking"
      note: "if without else for guard clauses is acceptable when it returns/throws immediately"
      example_wrong: "if (x > 0) { return y; } else { return z; }"
      example_correct: "return x > 0 ? y : z;"
      
    - id: TRAILING_COMMA
      severity: error
      category: syntax
      description: "Every multi-line collection must end with trailing comma"
      rationale: "Reduces git diff noise and prevents merge conflicts"
      example_wrong: "[item1, item2]"
      example_correct: "[item1, item2,]"
      
    - id: NAMED_PARAMETERS
      severity: error
      category: syntax
      description: "Use named parameters for all non-obvious arguments"
      rationale: "Improves readability and prevents parameter order mistakes"
      example_wrong: "ResultFactory.Create(error)"
      example_correct: "ResultFactory.Create(error: E.Validation.Invalid)"
      
    - id: TARGET_TYPED_NEW
      severity: error
      category: syntax
      description: "Use target-typed new() instead of redundant type"
      rationale: "Reduces verbosity without losing type safety"
      example_wrong: "Dictionary<string, int> dict = new Dictionary<string, int>();"
      example_correct: "Dictionary<string, int> dict = new();"
      
    - id: COLLECTION_EXPRESSIONS
      severity: error
      category: syntax
      description: "Use collection expressions [] instead of old patterns"
      rationale: "Modern C# syntax, more concise and readable"
      example_wrong: "new List<int> { 1, 2, 3 }"
      example_correct: "[1, 2, 3,]"
      
    - id: FILE_SCOPED_NAMESPACE
      severity: error
      analyzer: IDE0161
      category: syntax
      description: "Use file-scoped namespace declarations"
      rationale: "Reduces indentation and improves readability"
      example_wrong: "namespace X { ... }"
      example_correct: "namespace X;"
      
    - id: ONE_TYPE_PER_FILE
      severity: error
      analyzer: CA1050
      category: syntax
      description: "Never put multiple top-level types in same file"
      rationale: "Improves discoverability and maintains single responsibility"
      
    - id: KR_BRACE_STYLE
      severity: error
      category: syntax
      description: "K&R brace style - opening braces on same line"
      rationale: "Consistent code style across repository"
      example_wrong: "void Foo()\n{"
      example_correct: "void Foo() {"
      
    - id: PATTERN_MATCHING
      severity: error
      category: syntax
      description: "Use pattern matching for type discrimination"
      rationale: "More expressive and safer than casting"
      example_wrong: "if (obj is Point3d) { var p = (Point3d)obj; ... }"
      example_correct: "return obj switch { Point3d p => Process(p), ... };"
      
    - id: PRIMARY_CONSTRUCTORS
      severity: warning
      category: syntax
      description: "Prefer primary constructors for simple classes"
      rationale: "Reduces boilerplate code"
      example_correct: "public class Config(int value, string name) { }"

  architecture:
    - id: RESULT_MONAD
      severity: error
      category: architecture
      description: "Always use Result<T> for error handling - never exceptions"
      rationale: "Makes error handling explicit and composable"
      implementation: "libs/core/results/Result.cs, ResultFactory.cs"
      example_correct: "return ResultFactory.Create(error: E.Validation.Invalid);"
      
    - id: UNIFIED_OPERATION
      severity: error
      category: architecture
      description: "Use UnifiedOperation for all polymorphic dispatch"
      rationale: "Centralizes polymorphic logic with validation"
      implementation: "libs/core/operations/UnifiedOperation.cs"
      example_correct: "UnifiedOperation.Apply(input, operation, config)"
      
    - id: ERROR_REGISTRY
      severity: error
      category: architecture
      description: "All errors defined in E.* registry"
      rationale: "Centralized error management with code ranges"
      implementation: "libs/core/errors/E.cs"
      code_ranges:
        results: "1000-1999"
        geometry: "2000-2999"
        validation: "3000-3999"
        spatial: "4000-4999"
      example_correct: "E.Validation.GeometryInvalid"
      
    - id: VALIDATION_RULES
      severity: error
      category: architecture
      description: "Use V.* flags for validation modes"
      rationale: "Bitwise composition of validation rules"
      implementation: "libs/core/validation/ValidationRules.cs"
      example_correct: "V.Standard | V.Degeneracy"
      
    - id: NO_HELPER_METHODS
      severity: error
      category: architecture
      description: "No helper methods or Extract Method refactoring"
      rationale: "Encourages dense, algorithmic code over sprawl"
      note: "If you hit 300 LOC limit, improve algorithm, don't extract"

  performance:
    - id: LOOP_OPTIMIZATION
      severity: warning
      category: performance
      description: "Choose appropriate iteration pattern for context"
      guidelines:
        hot_paths: "Use for loops with index access (2-3x faster)"
        clarity: "Use LINQ for readability (80-90% of code)"
        large_datasets: "Consider Parallel.ForEach for CPU-bound operations"
      
    - id: AVOID_MATERIALIZATION
      severity: warning
      category: performance
      description: "Don't call .ToList()/.ToArray() unless needed"
      rationale: "Unnecessary allocations and performance cost"
      example_wrong: "items.Where(p).ToList().Count"
      example_correct: "items.Count(p) or items.Any(p)"
      
    - id: FROZEN_DICTIONARY
      severity: info
      category: performance
      description: "Use FrozenDictionary for static dispatch tables"
      rationale: "Faster lookups than regular Dictionary"
      implementation: "libs/rhino/spatial/Spatial.cs"

# Organizational constraints
limits:
  files_per_folder:
    maximum: 4
    ideal: "2-3"
    description: "Maximum files per implementation/feature folder"
    rationale: "Forces better code organization and consolidation"
    
  types_per_folder:
    maximum: 10
    ideal: "6-8"
    description: "Maximum types per folder (across all files)"
    rationale: "Maintains cohesion and prevents sprawl"
    
  loc_per_member:
    maximum: 300
    ideal: "150-250"
    description: "Maximum lines of code per member (method, property, etc.)"
    rationale: "Encourages dense, algorithmic code over procedural sprawl"
    note: "If you hit this limit, improve algorithm, don't extract helpers"

# Exemplar files to study before coding
exemplars:
  - path: "libs/core/validation/ValidationRules.cs"
    purpose: "Expression tree compilation, zero allocations"
    patterns: 
      - "ConditionalWeakTable caching"
      - "Expression tree compilation"
      - "Generic type handling"
    loc: ~150
    
  - path: "libs/core/results/ResultFactory.cs"
    purpose: "Polymorphic parameter detection with pattern matching"
    patterns:
      - "Complex overload resolution"
      - "Type discrimination"
      - "Factory pattern"
    loc: ~180
    
  - path: "libs/core/operations/UnifiedOperation.cs"
    purpose: "Complete polymorphic dispatch engine in 108 lines"
    patterns:
      - "Generic type constraints"
      - "Validation pipeline"
      - "Error accumulation"
    loc: 108
    
  - path: "libs/core/results/Result.cs"
    purpose: "Monadic composition with lazy evaluation"
    patterns:
      - "Monad pattern"
      - "Method chaining"
      - "Lazy evaluation"
    loc: ~200
    
  - path: "libs/rhino/spatial/Spatial.cs"
    purpose: "FrozenDictionary dispatch with algorithmic density"
    patterns:
      - "FrozenDictionary dispatch"
      - "Static readonly optimization"
      - "Type-based dispatch"
    loc: ~120

# Build configuration references
build:
  analyzers:
    - name: "Roslynator.Analyzers"
      version: "4.14.1"
    - name: "Meziantou.Analyzer"
      version: "2.0.256"
    - name: "Microsoft.CodeAnalysis.NetAnalyzers"
      version: "10.0.100"
    - name: "AsyncFixer"
      version: "1.6.0"
    - name: "ReflectionAnalyzers"
      version: "0.3.1"
    - name: "Nullable.Extended.Analyzer"
      version: "1.15.6581"
      
  enforcement:
    TreatWarningsAsErrors: true
    EnforceCodeStyleInBuild: true
    AnalysisLevel: "latest-all"

# Common patterns that must be followed
patterns:
  result_monad:
    creation:
      - "ResultFactory.Create(value: x)"
      - "ResultFactory.Create(error: E.Domain.ErrorName)"
      - "ResultFactory.Create(errors: [e1, e2,])"
    chaining:
      - ".Map(x => Transform(x))"
      - ".Bind(x => ComputeResult(x))"
      - ".Ensure(pred, error: E.Domain.Name)"
      - ".Match(onSuccess, onFailure)"
      
  unified_operation:
    structure: |
      UnifiedOperation.Apply(
          input: data,
          operation: (Func<TIn, Result<IReadOnlyList<TOut>>>)(item => item switch {
              Type1 t1 => Process1(t1),
              Type2 t2 => Process2(t2),
              _ => ResultFactory.Create<IReadOnlyList<TOut>>(error: E.Geometry.Unsupported),
          }),
          config: new OperationConfig<TIn, TOut> {
              Context = context,
              ValidationMode = V.Standard | V.Degeneracy,
              AccumulateErrors = false,
          });
          
  validation_modes:
    flags:
      - "V.None"
      - "V.Standard"
      - "V.Degeneracy"
      - "V.Topology"
      - "V.All"
    usage: "Combine with | operator: V.Standard | V.Degeneracy"
    
  error_registry:
    usage:
      - "E.Validation.GeometryInvalid"
      - "E.Geometry.InvalidCount.WithContext(\"msg\")"
    never: "Never construct SystemError directly - use E.* constants"

# Target files that will be generated from this standard
generation_targets:
  - file: "CLAUDE.md"
    type: "full"
    description: "Comprehensive coding standards with examples and rationale"
    
  - file: ".github/copilot-instructions.md"
    type: "condensed"
    description: "Condensed rules for GitHub Copilot IDE integration"
    
  - file: ".github/agents/*.agent.md"
    type: "critical_rules_section"
    description: "[CRITICAL RULES] section in each of 11 agent files"
    count: 11
    agent_files:
      - "csharp-advanced.agent.md"
      - "testing-specialist.agent.md"
      - "refactoring-architect.agent.md"
      - "rhino-implementation.agent.md"
      - "grasshopper-implementation.agent.md"
      - "performance-analyst.agent.md"
      - "documentation-specialist.agent.md"
      - "integration-specialist.agent.md"
      - "cleanup-specialist.agent.md"
      - "library-planner.agent.md"
      - "plugin-architect.agent.md"
